什么是“中文信息处理”
•中文信息处理
是用计算机对汉语的音、形、义等语言文字信息进行的加工和操作，包括对字、词、短语、句、篇章的输入、输出、识别、转换、压缩、存储、检索、分析、理解和生成等各方面的处理技术。
《
计算机科学技术百科全书
》
清华大学出版社
，1998
•中文
•广义：中国境内使用的文字和语言，包括各种少数民族文字及语言
•狭义：汉字，汉语文

中文信息处理研究什么？
•
•解决中文在计算机
解决中文在计算机/
/信息系统中的
信息系统中的
输入、存储、传输、显现、转换、
输入、存储、传输、显现、转换、加工、
加工、理解
理解
3
处理对象：
处理对象：字符
字符
处理对象：
处理对象：文本
文本

我们将学到什么？
•了解中文信息处理的概念、发展历史、研究内容；
•了解中文信息处理的基础知识；
•掌握操作系统实现中文信息处理的基本原理；
•熟悉计算机汉字编码字符集标准；
•熟悉常用的汉字输入法编码方法；
•掌握Linux操作系统下中文输入法的安装和使用方法；
•掌握Linux操作系统下输入法开发的基本方法；
•熟悉汉字字形存储与压缩技术；
•了解Linux操作系统的国际化和本地化机制；
•掌握Linux操作系统下国际化软件开发方法；
•熟悉汉语分词、信息检索等自然语言理解的基础知识。
4

5参考教材
•朱巧明，李培峰，吴娴，朱晓旭等编著。中文信息处理技术教程
中文信息处理技术教程，清华大学出版社，2005
•宋继华，杨尔弘，王强军。中文信息处理教程(普通高等教育十一五国家级规划教材)。高等教育出版社，2011
•宗成庆著。统计自然语言处理（第2版）。清华大学出版社，2013
•Christopher D.Manning，HinrichSchutze。统计自然语言处理基础
统计自然语言处理基础，电子工业出版社，2005

先修课程
•数据结构与算法
•Linux应用编程技术
6

参考资料
•http://www.zdic.net/
•http://www.pkucn.com/forum.php
•http://www.unicode.org
•http://en.wikipedia.org/wiki/B%C3%A9zier_curve
•http://en.wikipedia.org/wiki/TrueType
•http://en.wikipedia.org/wiki/OpenType
•http://nutch.apache.org/
•http://lucene.apache.org/solr/
•https://fcitx-im.org/wiki/Fcitx
•http://blog.csdn.net/likika2012/article/details/17026935http://www.pkucn.com
/forum.php
•http://ictclas.nlpir.org/
•http://technology.chtsai.org/mmseg/
•http://home.hylanda.com/
7

怎
怎么
么学
学？
？
——课程计划
8•第1章：中文信息处理基础
•第2章：输入法与文字识别
•第3章：信息检索

中文信息处理基础
主讲人：刘汇丹副研究员
huidan@iscas.ac.cn
中国科学院软件研究所
2015年10月29日
9
《
《操作系统定制技术
操作系统定制技术》
》
第二部分
第二部分中文信息处理
中文信息处理
第
第7
7章
章中文信息处理基础
中文信息处理基础(1)
(1)
第一节：
第一节：中文信息处理
中文信息处理概述
概述

提纲
•第一节：中文信息处理概述
•第二节：计算机编码字符集概述
•第三节：计算机文字输出技术概述
•第四节：Graphite字库技术概述
10

11第一节：中文信息处理概述
现代汉语的特点
信息处理
中文信息处理
计算机中文信息处理主要研究对象
中文信息处理的发展历程
其他

中文信息处理
中文信息
日文信息
英文信息
………
信息处理
12
文字信息

13信息
•控制论创始人（维纳Norbert Wiener）
–信息既不是物质也不是能量，是人类在适应外部世界时
以及在感知外部世界时而作出协调时与外部环境交换内
容的总和。
•信息论奠基者（香农Clause Shannon）
–信息就是能够用来消除不确定性的东西，是一个事件发
生概率的对数的负值
•Robert M. Losee
–信息可以被定义为一个处理过程的特征，这些特征就是
输入和处理过程中产生的信息

14信息处理
•
•信息处理
信息处理
就是对信息的接收、存储、转化、传送和
发布
–信息的接收：包括信息的感知、信息的测量、信息的识
别、信息的获取以及信息的输入等；
–信息的存储：把接收到的信息或转换、传送或发布中间
的信息通过存储设备进行缓冲、保存、备份等处理；
–信息的转化：把信息根据人们的特定需要进行分类、计
算、分析、检索、管理和综合等处理；
–信息的传送：把信息通过计算机内部的指令或者计算机
之间构成的网络从一地传送到另外一地；
–信息的发布：把信息通过各种表示形式展示出来。

15信息的分类
•按照计算机处理的信息形式
–文字信息
–多媒体信息
–超媒体信息：超级链接+多媒体
•按照信息的结构化程度
–结构化信息：数据表，数据库
–半结构化信息：HTML
–非结构化信息
•按照信息的保密程度
–公开信息
–一般保密信息
–绝密信息

文字信息的特点
•文字信息处理的实质
–建立传统的真实世界的文字(古今中外)与计算机世界(虚拟世界)的联系，即，文字信息数字化•用一个固定的数码代表一个字母或文字，统称为代码(code)–英文以26个字母作为文字信息处理的单位，要对26个字母逐个地确定代替它的数码–汉字以“字”作为语义的最小单元，也是文字信息处理的基本单位，因此要对每个“汉字”唯一地确定代表它的数码
•文字数字化必须采用大家通用的编码方式，否则，计算机里的文字信息就不能交流和共享
•这种被大家广泛接受和采用的文字编码方法也就是文字编码标准
16Word 字1010110

汉字的属性
形
音
义
17
字字字...
字字字...
zi
文字
表字
…汉语中最小的构词单元

18字音
•汉字读音的标记方法
–直音法
•用一个汉字给另一个汉字进行注音
•“厶”→“司”，“翯”→“贺”
–反切法
•用两个汉字给另外一个汉字注音
•“鲁”→“郎古”，第一个汉字为声母，第二个汉字是韵母和声调
–注音字符
•汉语拼音
•21个声母，35个韵母，4声调

19字形
•汉字结构
–笔画
•汉字字形最小连笔单位
•五种基本笔画：横、竖、撇、点、折
–部首
•字形归类的部件，是字典根据汉字形体偏旁所分的门类
•繁体字和简体字
–“進”→“进”，“裏”→“里”
–繁体字和简体字并不是一一对应的关系
•字序
–义序、音序、形序
http://baike.haosou.com/doc/5383339-5619733.html

汉字的特点
•
•字形、字音与字义三者的统一体，具有明显的直观性和表意性
字形、字音与字义三者的统一体，具有明显的直观性和表意性
•
•字形、字音与字义三者的统一体，具有明显的直观性和表意性
字形、字音与字义三者的统一体，具有明显的直观性和表意性
象形文字
象形文字
•
•常用字约
常用字约3000
3000多个
多个•
•2013
2013年
年8
8月，国务院公布
月，国务院公布《
《通用规范汉字表
通用规范汉字表》
》收录汉字
收录汉字8105
8105个
个
•
•常用字约
常用字约3000
3000多个
多个•
•2013
2013年
年8
8月，国务院公布
月，国务院公布《
《通用规范汉字表
通用规范汉字表》
》收录汉字
收录汉字8105
8105个
个
字多
字多
•
•每一个汉字都有其固定的书写形式
每一个汉字都有其固定的书写形式•
•汉字是一个二维结构图形，形态多样、美观、自然
汉字是一个二维结构图形，形态多样、美观、自然
•
•每一个汉字都有其固定的书写形式
每一个汉字都有其固定的书写形式•
•汉字是一个二维结构图形，形态多样、美观、自然
汉字是一个二维结构图形，形态多样、美观、自然
形美
形美
•
•汉字发音只有
汉字发音只有410
410余个，加上四声和轻声变化，共
余个，加上四声和轻声变化，共1300
1300余种
余种
•
•汉字发音只有
汉字发音只有410
410余个，加上四声和轻声变化，共
余个，加上四声和轻声变化，共1300
1300余种
余种
音少
音少
•
•每一个汉字都有与同其字形结构紧密相联的特定的含义，一般有
每一个汉字都有与同其字形结构紧密相联的特定的含义，一般有2~5
2~5个，多的有
个，多的有6~9
6~9个义项
个义项
•
•每一个汉字都有与同其字形结构紧密相联的特定的含义，一般有
每一个汉字都有与同其字形结构紧密相联的特定的含义，一般有2~5
2~5个，多的有
个，多的有6~9
6~9个义项
个义项
义众
义众
•
•在不同的语境下同一个字可以作为不同的类型
在不同的语境下同一个字可以作为不同的类型
•
•在不同的语境下同一个字可以作为不同的类型
在不同的语境下同一个字可以作为不同的类型
类难
类难
•
•汉字的字序不明显，例如，笔画序
汉字的字序不明显，例如，笔画序(214
(214部首、
部首、201
201部首
部首)
)、音序
、音序
•
•汉字的字序不明显，例如，笔画序
汉字的字序不明显，例如，笔画序(214
(214部首、
部首、201
201部首
部首)
)、音序
、音序
序隐
序隐
20

汉语的词汇（一）
•能独立运用的特有的音、形、义的最小语法单位
•是语言中所有的词和短语的总和
–绝大多数汉字可以独立构词
•“我”
——英语中的单一字母构成的词汇，“I”
–现代汉语大多数词语都是由两个以上的汉字构成
•汉字的高效率体现在几百个基本象形字可以合成表
示天上地下的各种事物的上万汉字几千个常用字又
可以轻松组合出数十万词语
21

22汉语的词汇（二）
汉语词汇的种类
汉语词汇的种类
•
•单纯词
单纯词
•
•由一个语素构成的词，如人、走、
由一个语素构成的词，如人、走、天
天
•
•双音节连绵词，如鸳鸯、垃圾、琳
双音节连绵词，如鸳鸯、垃圾、琳琅、葡萄
琅、葡萄
•
•音译词，如沙发（
音译词，如沙发（sofa
sofa
），咖啡
），咖啡（
（coffee
coffee），哈尔滨、呼和浩特
），哈尔滨、呼和浩特
•
•合成词
合成词
•
•重叠词：两个相同的词根相叠构成
重叠词：两个相同的词根相叠构成的词，如哥哥、姐姐、星星
的词，如哥哥、姐姐、星星
•
•附加词：由词根和词缀构成，如老
附加词：由词根和词缀构成，如老虎、石头、刀子、桌子
虎、石头、刀子、桌子
•
•复合词：内部结构基本上是和句法
复合词：内部结构基本上是和句法结构一致的，有主谓、偏正、联合
结构一致的，有主谓、偏正、联合等，如质量、体制、开关
等，如质量、体制、开关
•
•单纯词
单纯词
•
•由一个语素构成的词，如人、走、
由一个语素构成的词，如人、走、天
天
•
•双音节连绵词，如鸳鸯、垃圾、琳
双音节连绵词，如鸳鸯、垃圾、琳琅、葡萄
琅、葡萄
•
•音译词，如沙发（
音译词，如沙发（sofa
sofa
），咖啡
），咖啡（
（coffee
coffee），哈尔滨、呼和浩特
），哈尔滨、呼和浩特
•
•合成词
合成词
•
•重叠词：两个相同的词根相叠构成
重叠词：两个相同的词根相叠构成的词，如哥哥、姐姐、星星
的词，如哥哥、姐姐、星星
•
•附加词：由词根和词缀构成，如老
附加词：由词根和词缀构成，如老虎、石头、刀子、桌子
虎、石头、刀子、桌子
•
•复合词：内部结构基本上是和句法
复合词：内部结构基本上是和句法结构一致的，有主谓、偏正、联合
结构一致的，有主谓、偏正、联合等，如质量、体制、开关
等，如质量、体制、开关
汉语的词根和词缀
汉语的词根和词缀
•
•词根：意义实在、在合成内位置
词根：意义实在、在合成内位置不固定的粘着语素
不固定的粘着语素(
(不能单独构成
不能单独构成词的语素，如伟、丰、型
词的语素，如伟、丰、型)
)和自由
和自由语素
语素(
(能独立成词的语素，如金、
能独立成词的语素，如金、木、水、火、土
木、水、火、土)
)
•
•词缀：意义不实在、在合成内位
词缀：意义不实在、在合成内位置固定在前或后的粘着语素
置固定在前或后的粘着语素
•
•“筷子”
“筷子”→
→“筷”是词根语素，
“筷”是词根语素，“子”是词缀语素
“子”是词缀语素
•
•词根：意义实在、在合成内位置
词根：意义实在、在合成内位置不固定的粘着语素
不固定的粘着语素(
(不能单独构成
不能单独构成词的语素，如伟、丰、型
词的语素，如伟、丰、型)
)和自由
和自由语素
语素(
(能独立成词的语素，如金、
能独立成词的语素，如金、木、水、火、土
木、水、火、土)
)
•
•词缀：意义不实在、在合成内位
词缀：意义不实在、在合成内位置固定在前或后的粘着语素
置固定在前或后的粘着语素
•
•“筷子”
“筷子”→
→“筷”是词根语素，
“筷”是词根语素，“子”是词缀语素
“子”是词缀语素

汉语词汇的特点
•
•含义丰富，但长度相对英文词汇短
含义丰富，但长度相对英文词汇短
•
•含义丰富，但长度相对英文词汇短
含义丰富，但长度相对英文词汇短
词长短
词长短
•
•词义较多，一词多义比较普遍
词义较多，一词多义比较普遍
•
•词义较多，一词多义比较普遍
词义较多，一词多义比较普遍
词义众
词义众
•
•可以利用汉字灵活组合，组词方便，例如，高大上、不明觉厉
可以利用汉字灵活组合，组词方便，例如，高大上、不明觉厉
•
•可以利用汉字灵活组合，组词方便，例如，高大上、不明觉厉
可以利用汉字灵活组合，组词方便，例如，高大上、不明觉厉
构成与复合便
构成与复合便
•
•可以通过灵活组合形成汉语句子
可以通过灵活组合形成汉语句子
•
•可以通过灵活组合形成汉语句子
可以通过灵活组合形成汉语句子
组句活
组句活
•
•汉语词汇数量大，不用行业使用不同的词汇
汉语词汇数量大，不用行业使用不同的词汇
•
•汉语词汇数量大，不用行业使用不同的词汇
汉语词汇数量大，不用行业使用不同的词汇
数量大
数量大
•
•用词相对集中，常用词
用词相对集中，常用词(
(包括常用单字词
包括常用单字词)
)使用频度高，覆盖面大
使用频度高，覆盖面大
•
•用词相对集中，常用词
用词相对集中，常用词(
(包括常用单字词
包括常用单字词)
)使用频度高，覆盖面大
使用频度高，覆盖面大
词频集中
词频集中
•
•常用词构词比较有规律，相对容易辨识，如，四字词、两字词、单
常用词构词比较有规律，相对容易辨识，如，四字词、两字词、单字词等
字词等
•
•常用词构词比较有规律，相对容易辨识，如，四字词、两字词、单
常用词构词比较有规律，相对容易辨识，如，四字词、两字词、单字词等
字词等
识别易
识别易
•
•不同用法中类型变化较大，词类容易混
不同用法中类型变化较大，词类容易混(
(相对英文
相对英文)
)
•
•不同用法中类型变化较大，词类容易混
不同用法中类型变化较大，词类容易混(
(相对英文
相对英文)
)
词类混
词类混
•
•汉文语句、词由汉字单字组成，字与字、词与词间没有间隔符
汉文语句、词由汉字单字组成，字与字、词与词间没有间隔符
•
•汉文语句、词由汉字单字组成，字与字、词与词间没有间隔符
汉文语句、词由汉字单字组成，字与字、词与词间没有间隔符
切分难
切分难
23

24汉语句子
•句子：能够表达一个相对完整意思的并且有一个特定语调的语言单位
•汉语句子是“以意为本”的，生成的第一要素是语义
–无论是否是主谓结构的，只要完成表意功能，就是一个句子

25字频
•字频：就是一个汉字的相对使用频率，也就是一个汉字使用次数与所统计的材料的总字数的比例
–如果在一篇2000字的文章中，“的”使用了78次，则“的”的频率就是
78/2000*100%=3.9%
•在信息检索中有着重要的应用–文本分类–信息检索中索引表的建立–……

26词频
•词频：就是一个词的相对使用频率
•对于词典的编撰、中文信息处理有着重要的作用
–新词的出现：•【不明觉厉】虽然不明白你在说什么，但是听起来感觉很厉害的样子。
表面词义用于表达菜鸟对专业型技术型高手的崇拜，引申词义用于吐槽对方过于深奥不知所云，或作为伪装自己深藏不露的托辞。•【男默女泪】2010年初出现的网络用语，全称为“男生看了会沉默，女生看了会流泪”，常用来形容某篇文章的主题，多与情感爱情有关。•【火钳刘明】是“火前留名”的意思，通常在一些有争议的作品刚出来时使用，表示看好这作品会火的可能性，而在前排留名。此外，“山前刘明”是“删前留名”的意思。•【喜大普奔】是“喜闻乐见、大快人心、普天同庆、奔走相告”的缩略。•【细思恐极】是“仔细想想，觉得恐怖至极”的意思。•【人艰不拆】是“人生已经如此艰难，有些事情就不要拆穿了”的意思。
–信息检索

现代汉语的特点——语音
现代汉语具有区别于印欧语系语言的许多特点
音节界限分明，乐音较多，加上声调高低变化和语调的抑扬顿挫，因而具有音乐性强的特点
•没有复辅音：在一个音节内，无论开头还是结尾，都没有两个或三个辅音连在一起的现象。因此，汉语音节的界限分明，音节的结构形式比较整齐
•元音占优势：汉语音节中可以没有辅音，但不能没有元音。一个音节可以只由一个单元音或者一个复元音构成，同时，由复元音构成的音节也比较多，因元音是乐音，所以汉语语音乐音成分比例大
•有声调：每个音节都有一个声调，声调可以使音节和音节之间界限分明并富于高低升降的变化，于是形成了汉语音乐性强的特殊风格
27

•汉语语素以单音节为基本形式
–汉语单音语素多，构成的单音词和双音词也较多，词形较短
–汉语单音节基本上都是语义承担者，这些单音节可以作为语素构成大量单音词，也可以合起来构成合成词
•广泛运用词根复合法构成新词
–由于汉语中有意义的单音节语素几乎都能充当词根语素，词缀语素少而且造词能力较弱，因此，汉语中运用复合法组合词根语素构成合成词的情况最多
•双音节词占优势
–汉语词汇在发展过程中逐渐趋向双音节化•过去的单音节词有的被双音节词代替，如，目—眼睛、石—
石头•有些多音节短语也被缩减为双音节词，如，外交部长—外长，彩色电视机—彩电•新造词也多为双音节的，如，弱智、离休。
–现代汉语词汇中的三音节词也有所发展，但双音节词仍然是多数
28现代汉语的特点——词汇

现代汉语的特点——语法
汉语缺乏形态，即缺乏表示语法意义的词形变化
•语序和虚词是表达语法意义的主要手段
–例如“不很好”和“很不好”，因语序不同，所表示的意义也不一样•在“我和弟弟”及“我的弟弟”中–“和”表示并列关系，“的”表示偏正关系，由于虚词“和”与“的”的不同，因此表示的语法关系和意义也不相同
•词、短语和句子的结构原则基本一致
–都有主谓、动宾、补充、偏正、联合五种基本语法结构关系•例如词“地震”，短语“身体健康”，句子“火车开动了”等，都是主谓结构
•词类和句法成分不是简单的对应关系
–汉语中词类和句子成分的关系比较复杂，不像印欧语那样有简单的对应关系•同一词类可以充当多种句法成分，词在语法方面呈现出多功能性；同一种句子成分又可以由几类词充当，两者之间又具有一定的灵活性
–量词十分丰富，有语气词•数词和名词结合时，一般要在数词的后面加个量词，不同名词所用的量词不同–如“一个人、一头牛、一张纸、一粒米”等•语气词常出现在句末，表示各种语气的细微差别–如“是他吗？”“是他吧？”“是他呢。”29

不大一样
30大不一样
不大一样
不一样大一样不大

31什么是“中文信息处理”
•中文信息处理
是用计算机对汉语的音、形、义等语言文字信息进行的加工和操作，包括对字、词、短语、句、篇章的输入、输出、识别、转换、压缩、存储、检索、分析、理解和生成等各方面的处理技术。
《
计算机科学技术百科全书
》
清华大学出版社
，1998
•中文
•广义：中国境内使用的文字和语言，包括各种少数民族文字及语言
•狭义：汉字，汉语文

在计算机中处理中文信息需要解决哪几个方面的问题
？
32
输出？
处理？
传输？
存储？
输入？计算机中文信息主要的研究对象
汉字键盘输入技术
汉字字形识别技术
汉语语音识别技术
汉字字符集编码标准
汉字内码
汉字字符集编码标准
汉字内码
汉语语音合成技术
文本分类
信息检索
机器翻译，……
汉字输出技术
激光照排/字处理软件技术
汉语语音合成技术

输入设备
33

输出设备
34

存储设备
35

输出软件
•文本阅读（编辑）器
•图片阅读器
•音频播放器
•视频播放器
•……
36

37激光照排/字处理软件技术
•激光照排，即电子排版系统
–1946年，美国人发明了手动光学照相排版机
–20世纪60年代，德国人制造了阴极射线管式照排
–1975年，英国人开始了激光照排的研究
–1974年8月，国家设立了748工程
•字处理软件
–在个人电脑/桌面系统上进行文字编辑、排版处理
–典型的产品
•Word(微软, 1995)
•WordPerfect(Satellite SoftwareInternational, 1980)
•OpenOffice/
LibreOffice(StarDivision/Sun，1998)
–第一个中文字处理软件产品
•金山WPS(1993年)

38计算机中文信息处理主要研究对象
•汉字键盘输入技术
•汉字输出技术
•软件汉化技术
•汉字字形识别技术
•汉语语音识别技术
•激光照排/字处理软件技术
•中文平台
•汉语语音合成技术
•文本分类
•信息检索
•机器翻译
•……
文字信息
文本信息

39汉字键盘输入技术
•汉字键盘输入技术是一种通过键盘使汉字进入计算
机的技术
•汉字编码
–把汉字用“0”
—”9”十个数字按照次序进行编码
–四角码（字形码）
•用“0”—”9”十个数字键对汉字的四个角的形状进行编码
–机内码
•用2字节、3字节、4字节来表示一个汉字的机器内部码
–国际标准化组织（ISO）、Unicode联盟以及IEEE下属的
专门委员会研究制订的字符编码标准

输入软件：输入法
40
语音识别
手写识别
文字

存储
•各种信息在计算机中以“文件”的形式存在
•文字在文件中以“内码”表示
•“内码”本质上就是数字：0~XXXXXXX
41
用几来表示汉字“年”？
用几来表示汉字“年”？

42汉字输出技术
把存储在计算机内的汉字字形信息转换成符合显现
(显
示或打印)需要的形式，并送输出设备输出
•汉字字库
–点阵字库
•GB5199.1-2001和GB5007-2001是典型的16点阵和24点阵字库
–矢量字库
•采用矢量的方法，对每个汉字信息用一组矢量进行描述
–曲线字库
•采用二次曲线和三次曲线逼近字型轮廓对汉字字型进行描述–TrueType字库–OpenType字库–PostScript字库–Graphite字库

输出软件：文字是怎么输出的？
43
文本解释引擎
字符字形

44软件汉化技术
•早期（2000年以前）
–软件汉化是把英文软件直接改造成中文软件的一种技术
–解决在英文软件环境下处理汉字信息
•7位字符软件环境
•8位字符软件环境
•西文操作系统汉化成中文操作系统–内核汉化–外挂汉化
–西文应用软件经过汉化后能够具备处理中文的能力
•应用程序中中文的通行
•现在
–界面的汉化

45汉字字形识别技术
•利用计算机技术对汉字静态图形和动态汉字书写
信
息进行特征提取，与预先存储在计算机内的标准汉
字特征信息进行匹配，并选择符合特征的汉字作为
所需识别的汉字内码
–联机识别
–脱机识别
•汉字字形识别过程
–汉字识别前处理
–汉字分类和判别
–汉字识别后处理

46汉语语音识别技术
•自然语言处理的一个重要组成部分，包括语音的识
别、处理等
•语音识别的过程
–语音识别单元的选取
–特征参数提取技术
–模式匹配及模型训练技术

汉语语音合成技术
•让计算机将文字“读”出来
•将文本信息用计算机合成为人类的语音数据，并播放出来的技术，即文本转语音TTS(text to speech)技术•“读”的声音清晰、可懂、自然、具有表现力•涉及声学、语言学、数字信号处理、中文信息处理等多个学科技术
•语音合成(Speech Synthesis)
–根据韵律建模的结果，从原始语音库中取出相应的语音基元，利用特定的语音合成技术对语音基元进行韵律特性的调整和修改，最终合成出符合要求的语音
–可以主要由硬件实现，也可以主要由软件实现
•发展方向
–提高合成语音的自然度
–丰富合成语音的表现力
–降低语音合成技术的复杂度
–多语种文语合成47

48中文平台
•中文平台是指处理中文信息的软件系统的集合，包括支持中文的系统软件、支撑软件和应用软件
–汉化平台：西文系统上外挂一层软件，使系统可以接收和输出汉字
–API平台：操作系统提供有关中文信息处理所需要的一套API接口
–中文平台：在API平台上再增加一些典型的与中文信息处理有关的应用软件工具或产品

49文本分类
•文本分类是一种确定文章所属类别的情报分析方法
–基于词的归类技术
–基于知识的归类技术
–基于信息的归类技术

50信息检索
•文本检索包括了文本信息的存储、组织、表现、查询及存取等各个方面–索引的建立–自动分类–自动聚类–文摘（单文档文摘、多文档文摘）–检索结果的排序（ranking）–分布式信息检索–…………

51中文信息处理的发展——萌芽阶段
•学习和理论探索的萌芽阶段
–这一阶段以介绍国外计算语言学领域的理论方法为主
•对国外相关领域的介绍，理论内容相对较少，主要偏重在各种上机实现的系统方面。范继淹、徐志敏、李家治、陈永明、冯志伟等人的介绍及其所研制的实验系统报告，是这方面的代表
•早期将国外的理论方法进行全面系统汉化的主要刊物有：1986年底创刊的《中文信息学报》、语言学界的《国外语言学》和《语言文字应用
》
•学者们在介绍国外先进的理论和方法同时，也有不少人结合汉语自身的特点，对这些理论和方法做了深入一步的探索，极少数人对自然语言理解做了深层次的带有哲学色彩的思考–1980年代中期宁春岩发表的《自然语言理解中的几个根本问题》，以及他译介的美国哲学家休伯特.德雷福斯(Hubert L. Dreyfus)的专著《计算机不能做什么--人工智能的极限》–语言学界袁毓林1993年发表了《自然语言理解的语言学假设》–这些早期的的研究和探索对确立中文信息处理的宏观格局起到了决定性的作用，奠定了中文信息处理后期的理论基础

52中文信息处理的发展——早期
•汉字信息处理为主的早期阶段
–1974年周恩来总理亲自批准了“七四八”工程（汉字信息处理系统
工程）
•标志着计算机中文信息处理技术受到了国家高度重视
•进入了第一个发展阶段——汉字信息处理时代
–七四八工程最初拟定的研发目标有三项
•精密型中文编辑排版系统
•中文信息检索系统
•中文信息远距通信系统

中文信息处理的发展
•中文信息处理发展历程经历一个马鞍型
——倪光南(2004年4月，第一届中文信息处理发展国际研讨会)
•从20世纪70年代至90年代中期算一个高潮期
•90年代后期进入低潮
•自90年代未起，中文信息处理由冷转热，再度活跃
53

中文信息处理的发展——第一个高潮
•时间
–1970年代中后期-1990年代中期
•核心问题
–解决汉字的输入、存储、显现(文字层面处理)•一批靠中文处理产品起家的企业：联想、方正、四通等•一批用户量巨大的汉字输入法：五笔字型、郑码、智能ABC、紫光、微软拼音等•一些与中文信息处理相关的专业迅速成长：北大方正、青鸟华光、王码、中易
•重要事件
–1974年，北京大学王选院士开始研发汉字激光照排系统
–1980年，国家标准《信息技术信息交换用汉字编码字符集基本集》GB 2312-1980颁布
–1983年左右，IBM PC引进中国
–1984年左右，CC-DOS问世(纯软件汉化方案)，1985年，联想汉卡问世
–1985~1994年，一批汉化操作系统陆续推出•DOS汉化系统应用较广：UCDOS(希望公司)•Unix类系统应用较广：C-Xenix(软件所)54

•重要事件
–1988年，软件所与AT&T合作，推出Unix操作系统国际化/
本地化机制
–1993年，ISO/IEC 发布《信息技术通用多八位编码字符集(UCS)  第一部分：体系结构和基本多文种平面》(ISO/IEC 10646.1-1993)；我国颁布等同采用的国家标准GB 13000.1-1993
–1994年，软件所受IBM委托，实现了第一个能处理2万多个汉字的中文平台
–1994年起，Windows3.1/3.2逐渐在我国普及，Windows中文平台问世•中文之星(新天地，1994)•RichWin(四通利方，1994)•Windows 3.2版起，自带中文支持功能，同时推出支持中文的Office办公套件
–1995年，微软推出Windows 95/Office 95，全面支持中文处理，可以处理20902个汉字•与ISO 10646.1-1993字汇相同的《汉字扩展内码规范》(GBK) 由全国信息技术标准化技术委员会发布
满足用户在日常工作、学习中处理汉字的需求。
满足用户在日常工作、学习中处理汉字的需求。
55中文信息处理的发展——第一个高潮

中文信息处理的发展——低潮
•时间
–1996年以后~2000年
•核心问题
–文字层面汉字处理技术成熟•满足用户在日常工作、学习中处理汉字的需求
–Windows系统普及，且原生具有中文处理能力•严重挤压国内中文平台厂商的市场生存空间
•重要时间
–1998年，北京大学俞士文教授发表《现代汉语语法信息词典》
–2000年，GB 18030-2000  《信息技术信息交换用汉字编码字符集基本集的扩充》•GBK内码标准化，扩充到四字节，0x81308130 ~ 0xFE39FE39，150多万码位空间•收录的汉字量增加7000字，达到27000余字
–2000~2001年，微软推出采用Unicode内码的Windows NT/2000/XP及Office2000•中文处理功能基本完备56

中文信息处理的发展——再度活跃
•时间
–2000年以后
•核心问题
–面向互联网应用的中文信息处理•信息分类，信息提取，自动问答，基于内容的快速信息检索，基于个性的信息推送，数字化图书馆和信息网格等
–处理对象从文字层面过度到文本层面，并向语义层面发展
•典型事件
–应用系统不断出现•检索系统：易宝北信TRS信息检索系统、百度信息检索、……•翻译系统：华建、中软译星、雅信CAT系统、传神WCAT系统、…..•…….
57

•典型事件
–语料库建设长足发展•2001年，北京大学、富士通发布《PFR人民日报标注语料库(版本1.0》–1998年人民日报为对象，2700万字–对600多万字节的中文文章进行了分词及词性标注•2006年，香港城市理工大学语言资讯科学研究中心建立了LIVAC(Linguistic variety in Chinese communities)语料库–研究使用中文的各个地区使用语言的异同。总字数为15,234,551字，经过自动切词和人工校对之后总词数约为8,869,900词•用来翻译和研究各种不同语言对比的语料库–北大、哈工大、东北大学建立的英汉双语语料库–北京外国语大学的北京日本学研究中心建立了2000万字的汉语和日语并行语料库•……
–技术突破•在国际评测中表现不俗–软件所在高精度信息检索国际评测TREC Hard取得第一名(孙乐，2004)–计算所在竞争最激烈的
NIST机器翻译评测中获得过第3名(2009年汉英项目总成绩)–自动化所在国际口语机器翻译评测IWSLT多次获得第一名(刘群，宗成庆)

第二节：计算机编码字符集概述
基本概念
ASCIIISO 646
ISO 2022
ISO 8859-
1/2/3/4/5/6/7/8/9
系列
GB 2312GBKGB 18030 
ISO 10646 GB 13000UNICODE

基本概念（一）
•文字(Script)
–用于一种或多种书面形式的语言的图形字符的集合
–文字(Script) ≠ 语言(Language)
•字符(Character)
–一种书写语言的最小元素，具有抽象的意义或外形•虽然在字符编码表上有每个字符的图形，但只是为了便于读者理解
•编码字符(coded character)
–字符及其编码表示，是文字在计算机内最基本的表达形式
–编码汉字≠ 与汉字编码•
•编码
编码汉字
汉字是汉字在计算机内最基本
计算机内最基本的表达形式•汉字编码是以一种符号序列表示汉字方法–例如，汉字的电报码、汉语拼音编码、五笔字型编码，等等
•编码字符集(coded character set)
–一组无歧义的规则，用以建立一个字符集和该字符集中的字符及其编码表示之间的对应关系
•字汇(Repertoire)
–一个字符集里收录的字符，与编码无关5

•字形(Glyph，Generic Glyph)vs字型(Font Image)
–字形(Glyph，Generic Glyph)•表示一个或多个字符抽象的形式字形图象的同义词•只关心字符的表现形式，以及构成这个字符的各个部件的相对位置关系，即这个字符书写的正确性，而不考虑字符书写是否美观。
–字型(Font Image)•用可视化的方式表述字符数据的字形集合–一个字型通常都带有一组参数，如大小、笔体(如，黑体、宋体，等等)、基线，当这些参数设定为特定的值后，就可以生成出一组可以用来显示的字型•文字的字型是书法艺术与信息技术结合的产物
•交换码(Interchange Code) 
vs内码(Internal Code)
–交换码(Interchange Code)•一种为在不同的计算机系统进行信息交换而定义的字符编码–通常采用某种标准的字符集编码，如，
ASCII、GB2312-1980、ISO 10646/Unicode，等等
–内码(机内码，Internal Code)•计算机设备或系统使用的、用来表示文字字符的代码–既可以直接采用编码字符集本身，例如，早期计算机采用
ASCII作为内码，Windows 7以UTF-16作为操作系统内部的编码–也可以是交换码的某种变形，如，GB内码、Big5码、UTF-8，等等6基本概念（二）

7
“字”
“Word”
??

8ASCII(American Standard Code for 
Information Interchange,美国标准信息交换
码)
用单个字节表示字符
范围：0~127(2^7 = 128)

9ISO 2022
•ISO2022 规定编码中可以表示的字符和字符集包括下列四类，其中编码扩充技术操作的对象主要是编码图形字符集和编码控制字符集。
–固定编码字符：定义了三个字符及其编码，分别为：ESCAPE(01/11)
，SPACE(02/00)，DELETE(07/15)；
–编码图形字符集：对图形字符集可容纳字符数上限有四种限制值：94、96、94^n、96^n，其中n>1，表示多字节字符集；
–编码控制字符集：最多可容纳32 字符；
–编码单独附加控制功能：一般用特定转义序列表示。

10•字符集编码元素

11•编码空间
用0~·255表示字符
(2^8 = 256)

12•编码空间中的不同区域应该按如下方式使用：
–CL：用于表示主控制功能集
–GL：用于表示94 字符或94^n 字符的图形字符集，加上SPACE、DELETE 
两个字符；或者用于表示96 字符或96^n 字符的图形字符集
–CR(仅对8 位编码)：或用于表示辅控制功能集，或不使用
–GR(仅对8 位编码)：用于表示94 字符或94^n 字符的图形字符集，或者用于表示96 字符或96^n 字符的图形字符集

13•ISO 2022 是一个通用的标准，提供的编码扩充技术非常灵活
，
要实现其全部功能
–一方面需要付出很大的代价–另一方面在特定的应用环境中常常是没有必要的–需要对ISO 2022 的功能进行定制以适应环境需求
•实际系统中实现的都是各种定制方案
–编码元素——编码空间的映射
•无论何种基于ISO 2022 的编码方案，都必须在数据处理和交
互之前就定制情况达成一致，实际实现中有多种方法就此达
成共识
–以标准化编码方案固定其定制情况。
•ISO 2022 没有限制动态协商和声明的手段，但作为可用手段
之一，提供了ACS(Announce Code Structure)转义序列，从而
可以用标准自身定义的方法进行定制

14ISO 4873(ECMA－43)
•确定了控制字符和ASCII字符的位置

15ISO 8859-1/2/3/4/5/6/7/8/9系列
•ISO/IEC 8859系列
•8-bit的ASCII码扩展
–0x80~0xFF之间定义了一批拼音文字及符号
–.1  Latin alphabet No.1       法、德、意大利、西班牙...
–.2  Latin alphabet No.2       捷克、阿尔巴尼亚、克罗地亚...
–.3  Latin alphabet No.3       世界语、英语、拉丁语...
–.4  Latin alphabet No.4       丹麦语、爱沙尼亚语、挪威语...
–.5  Latin/Cyrillic alphabet  斯拉夫语系、俄语、乌克兰语...
–.6  Latin/Arabic alphabet    阿拉伯语
–.7  Latin/Greek alphabet     希腊语
–.8  Latin/Hebrew alphabet  希伯来语
–.9  Latin alphabet No.5        …...

16

17ISO 2022 的派生
•ISO-2022-CN：
–使用G0、G1、G2，G0 固定指派为ASCII(隐含了C0 的ASCII 控制字符
)
–G1 可以通过转义序列指派为GB 2312-80 或CNS 11643-1992 平面1
–G2 可以通过转义序列指派为CNS 11643-1992 平面2
•EUC-CN：
–仅使用G0、G1，并分别移位到GL、GR
–G0指派为GB 1988(ASCII)
–G1指派GB 2312-80 定义的字符集，不使用其他ISO 2022 控制功能

18《信息技术信息交换用汉字编码字符集基本集
》
GB 2312-1980
•编码范围–对任意图形字符都采用两个字节表示，每个字节均采用七位编码表示–用两个0x21~0x7E之间的十六进制数字代表一个汉字，0x2121~0x7e7e•例如，汉字“啊”的GB标准编码是0x3021•收录字符–收录字符共计7445个–一般符号202个，包括标点符号，运算符号等•序号60个，⒈~ ⒛，㈠~ ㈩，⑴~ ⒇，①~ ⑩•数字22个，0 ~ 9，Ⅰ~ Ⅻ•拉丁字母52个，26个大写，26个小写•日文假名169个•希腊字母48个•俄文字母66个•汉语拼音符号26个•汉语注音字母37个–汉字6763个，分成一、二两级•一级汉字3755个(常用字)，按汉语拼音序排列•二级汉字3008个(次常用字)，按偏旁部首顺序排列

19GB 2312-1980
•为了方便查找，GB 
2312-1980标准将整个编
码空间分为94个“区”，
每“区”中含有94个码
位，其中：
–01~09区为特殊符号–16~55区为一级汉字–56~87区为二级汉字–10~15区和88~94区则未分
配字符，通常用于用户自
定义的汉字。

GB 2312内码
•由于GB2312-1980标准的字符编码范围是0x21~0x7E，与ASCII编码范围重合
•在系统实现时，必须对GB标准编码进行一定的变化，才能与ASCII码区分开来
•统一到两字节高位置“1”的内码方案上。
•GB内码就从原来的0x21~0x7E偏移到0xA1~0xFE
•
•在
在八位的环境中
八位的环境中，汉字的两
，汉字的两个字节的最高位都为
个字节的最高位都为1
1，与
，与ASCII
ASCII兼容
兼容
•“3啊a”
0x43        0x30         0x210x61 
0100001100110000 0010000101100001
0x43        0xB0         0xA10x61 
0100001110110000 1010000101100001
20

21GB 2312内码表示

其他汉字标准及内码——台湾地区
•《中文标准交换码》TCA-CNS11643
–1980年9月，“行政院国家科学委员会”集合编码专家、学者制定
–1986年8月4日由“经济部中央标准局”公布《通用汉字标准交换码》•包括第1字面、第2字面共13,051字
–经过多年的使用意见及反馈不断扩充•1992年扩编至16个字面，使用至第7字面，共48,027字，并改称“中文标准交换码”(CSIC, Chinese Standard Interchange Code)•2004年版则扩充到80个字面，使用至第15字面•2014年，新增第19字面收录新字
•汉字内码
–Big-5码：1984年由台湾13家厂商与台湾地区财团法人信息工业策进会设计的双字节中文内码方案•第一个字节使用0x81-0xFE，第二个字节使用0x40-0x7E及0xA1-0xFE
–EUC-TW(Extended Unix Code)•codeset0 : ASCII•codeset1 : CNS 11643-1992 字面1，第一字节：0xA1-0xFE，第二字节：0xA1-0xFE•codeset2 : CNS 11643-1992字面2 –16，第一字节：0x8E，第二字节：0xA1-0xB0 (0xA1-0xA7分别代表第1~7字面，其余未定义)，第三、四字节：0xA1-0xFE
•codeset3 : [not used]，第一字节：0x8F，与codeset2相同
22

•字符集标准
–《七位元及八位元之双字节资讯交换用符号化汉字集》JISX 0208•1978年制订，其后于1983年、1990年、1997年修订•收录6879个图形字符，包括6355汉字和524个非汉字图形符号–01区-09区：非汉字图形字符–16区-84区：汉字»16区-47区：一级汉字(第1水準)2965个，48区-84区：二级汉字(第2水準)3390个–85区-94区：私人造字区
–《信息互换用辅助日语图形字符集规范》JIS X0212-1990 
•内码
–Shift_JIS•以下字符在Shift_JIS使用一个字节来表示–ASCII字符（0x20-0x7E），但“\”被“¥”取代，
ASCII控制字符（0x00-0x1F、0x7F）–JIS X 0201标准内的半角标点及片假名（0xA1-0xDF）•以下字符在Shift_JIS使用两个字节来表示–JIS X 0208字集的所有字符：第一字节：0x81-0x9F、0xE0-0xEF(共47个)，第二字节：0x40-0x7E、0x80-0xFC(共188个)–用户定义区：第一字节：0xF0-0xFC(共13个)，第二字节：0x40-0x7E、0x80-0xFC(共188个)–在Shift_JIS编码表中，并未使用0xFD、0xFE及0xFF•微软及IBM在0xFA
、0xFB及0xFC的两字节区域，加入388个JISX0208未收录的符
号和汉字
23其他汉字标准及内码——日本

其他汉字标准及内码——韩国和朝鲜
•字符集标准
–韩国：KS X 1001/
KS C 5601•韩国用于书写的谚文和汉字的字符集编码标准•94×94文字集合，共计8226字–包含谚文2350字、汉字4888字、英文字母、数字和假名
–朝鲜：KPS 9566-2003•构造与KS X 1001 类似–0x21 ～0x2C: 特殊文字区–0x2F: 用户定义区–0x30 ～0x4C: 谚文区（2679 个以朝鲜字母顺序排列的使用谚文）–0x4D ～0x7E: 汉字区（4653 个以朝鲜读音顺序排列的汉字）–0x4C 行和0x7E 行的0x50 列后各为用户定义区B、C
•内码
–EUC-KR
和EUC-KP•Codeset1：使用两个字节来表示，高字节：0xA1-0xFE，低字节：0xA1-0xFE
24

Code Page：代码页
•各国都在ISO 2022的框架下制定了本国的编码字符集标准
–ISO 8859系列标准、中国大陆的GB 2312、台湾地区的TCA-CNS 11643、日本的JIS和韩国的KCS标准等
–都兼容ASCII编码，但均需用使用编码0x80~0xFE
–因此，法文和德文的一些字符将使用同样的编码
–这时的软件只能实现双语处理，即，英文和其他一种本地文字，如法文、中文或日文，而不能实现多文种处理
•IBM公司于上世纪八十年代中在PC 5550的DOS操作系统中引入了“代码页(code page)”来描述特定编码字符集。
•不同的代码页支持不同国家或地区所使用的字符集，通过编号引用
–代码页936表示GB汉字字符集
–代码页932代表日文字符集
–代码页950代表Big5汉字字符集。
25
Windows中文版ANSI  = CP 936 = GB2312/GBK/GB18030

Code Page：代码页
26
21-7e
+80
CNS
KSC
JIS
GB
DPR
V

27ISO 10646/UNICODE
•ISO/IEC 10646
–Information Technology--Universal Multiple-Octet Coded Character(UCS) 
•ISO/IEC JTC1/SC2/WG2负责制定
•我国等同采用：GB 13000
–
–针对全世界现有的书面文字和符号统一编码
针对全世界现有的书面文字和符号统一编码
•Unicode：由企业组成的联盟
–非正式的国际团体Unicode Consortium (http://www.unicode.org
)
–Unicode原本是Apple公司的一个项目
•改进Macintosh 微机处理多语种文本的体系结构
–“Unicode标准，全球字符编码”，简称为Unicode
•1991年开始，共同制订标准
–ISO/IEC 10646与Unicode相互对齐

28ISO 10646/UNICODE编码空间
•正则形式(32-bit)
•每个字符表示为一个肆八位序列
•组(Group)八位平面(Plane)八位行八位(Row)   列八位(Cell)
•UCS-4，例如：00 00 00 41 表示字符A (U+00000041, U+0041)
A (U+00000041, U+0041)

29ISO 10646/UNICODE的0组
•定义了第0(BMP)、1、2、14平面
•预留第15、16平面作为私用平面
•实际编码空间0到16平面

30基本多文种平面(BMP)
蒙古文
蒙古文1800
1800-
-18FF
18FF阿拉伯
阿拉伯/ 
/ 维吾尔文：
维吾尔文：0600
0600-
-06FF
06FF藏
藏文
文0F00
0F00-
-0FFF
0FFF
藏文扩充集
藏文扩充集A
A
：
：F300
F300-
-F8FF
F8FF

31其他平面
•01平面：SMP(辅助多文种平面)
–拼音文字平面
•02平面：SIP (辅助表意字符平面)
–收入中日韩越统一编码汉字4万多个(Extension B)
•14平面：SSP(辅助特殊用途平面)
–控制字符的溢出分配区域，防止BMP平面上的控制字符区域太小无法容纳更多的控制字符
•15、16平面是私有专用平面
–0F0000-0F1645：藏文扩充集B

ISO 10646发展历程
•1993年发表ISO/IEC 10646 国际编码标准的首个版本——《Information technology -Universal Multiple-Octet Coded Character Set (UCS) -Part 1: Architecture and Basic Multilingual Plane》(ISO/IEC 10646-1:1993)
–A-Zone(19903个码位)：拼音字符和符号
–I-Zone (20992个码位)：收录了中日韩(CJK)统一汉字20902 个
–O-Zone(16384个码位)：保留
–R
-Zone (8190个码位)：限制使用
•2000年10月发表更新版ISO/IEC 10646-1:2000
–增加了一些拼音文字，如：Runic、Ogham、Khmer、…
–增加了中国少数民族语言，如：藏文、蒙古文、彝文
–将韩文Hangul从3400~4CFF移到AC00~D7FF
–在3400~4CFF新增收了CJK汉字6,582个，称CJK扩充集A(CJK Extension A)
–增加S-Zone(D800~DFFF)，用于表示UTF-16
–......
http://news.xinhuanet.com/edu/2008-01/24/content_7484992.htm 32

ISO 10646发展历程
•2001 年发表ISO/IEC 10646 第二部分《Information technology -Universal Multiple-Octet Coded Character Set (UCS) --Part 2: Supplementary Plane》(ISO/IEC 10646-2:2001)
–在02辅助平面收录CJK汉字字符42711个(CJK Extension B)
•2003年将第一和第二部分合并，形成《Information technology -Universal Multiple-Octet Coded Character Set (UCS)》(ISO/IEC 10646-2003)
–到2010年，又发布了7个补篇
–共收录CJK汉字字符74394个•CJK基本字符集：20902字•CJK扩充集A
：6582字•CJK扩充集B：42711字•CJK扩充集C：4149字•CJK兼容字符：542字•CJK兼容字符增补：361字•CJK部首扩充：115字•康熙字典部首：214字33

ISO 10646发展历程
•2011年，整合7个补篇，发布ISO/IEC 10646:2011
–CJK扩充集D：222字
•最新版：ISO/IEC 10646-1:2014
–收录CJK汉字字符74617个
–中国少数民族文字：藏文、蒙古文(满文/
锡伯文)、维吾尔/
哈萨克/
柯尔克孜文、彝文(凉山)、傣文(西双版纳傣文、老傣文、德宏傣文、金平傣文)……
•近期
–CJK扩展集E•已经进入投票阶段，计划放置于编码范围U+2B820-U+2F7FF中。•包含1277个越南汉字、闽南语和客家话使用的24个台湾汉字，2个大陆地名用字
–CJK扩展集F•现正处于研究阶段
34

中日韩统一编码汉字字符集(CJK)
•由Ideographic RapporteurGroup(IRG)工作组负责
ISO/IEC JTC1/SC2/WG2/IRG
•依据各国、地区的现行标准收入汉字
–对中(大陆、台湾、香港、澳门)、日、韩、越、新、朝提交的汉字进行甄别、认同、正形、排序、编码
–形成基本点阵字形(96×96)
–提交WG2
•原则
–属性分离原则•只考虑抽象的汉字字形，不考虑字音、字义
35

36
字
5B57 hex
Coded Character
编码汉字
Representation
•码
•频
•序
•形
•音
•义属性分离

37汉字属性
Unicode
码形Glyph
音义型频
国际性民族性Signifying 能指？字种？
Signified 所指？

38
•字
•字
•字
•字
•字
•字
•zi4
•王码
•郑码
•语音
•手写
•部首
•笔划
•仓吉
字
Presentinput
5B57 hex
Interchange  交换
Processing处理
InternetSignifying 
–能指
字种？

39ISO 10646的内码表示形式
•UCS-4–是ISO 10646 中的肆八位正则形式，即每个字符编码固定32 位，–由表示组、平面、行、字位的四个八位位组构成•UCS-2–是ISO 10646 中的双八位BMP 形式，字符编码固定16 位长，只能表示BMP 
内的字符编码，省略了固定为0 的组、平面两个八位位组•UTF-32–编码范围限于0～10FFFF以保证与UTF-16 的一致性–可以认为UTF-32 等同于UCS-4•UTF-16–对BMP 内字符使用16 位编码，与UCS-2 相同–对于超出BMP 的16 个平面(第1～16 平面)使用“替代对”(surrogate pair)机制，
用两个16 位编码表示一个字符–构成替代对的两个编码单元的范围分别是D800～DBFF和DC00～DFFF，编码
空间大小为210×210＝220，相当于16个平面。•UTF-8–以8 位的字节作为编码基本单位，字符编码长度1～6 字节可变–对于实际使用的前17 个平面而言，字符编码长度1～4 字节–保证了0～7F 范围内字符与ASCII 一致–相对于其他变长字符编码，UTF-8 成功解决了字符边界的界定问题

40•UTF-16
•UTF-8
有效位
 
最小值
(Hex)
 
最大值
(Hex)
 
二进制的位序列 
7
 00000000 0000007F 0vvvvvvv
 
11
 00000080 000007FF 110vvvvv 10vvvvvv 
16
 00000800 0000FFFF
 1110vvvv 10vvvvvv 10vvvvvv
 
21
 00010000 001FFFFF
 11110vvv 10vvvvvv 10vvvvvv 10vvvvvv
 
26
 00200000 03FFFFFF
 111110vv 10vvvvvv 10vvvvvv 
10vvvvvv 10vvvvvv 
31
 04000000 7FFFFFFF 1111110v 10vvvvvv 10vvvvvv 10vvvvvv 10vvvvvv 10vvvvvv
 
 
Unicode码点（Bit）UTF-16编码结果（Bit）
BMP平面xxxxxxxx xxxxxxxxxxxxxxxx xxxxxxxx
非BMP平面000uuuuu xxxxxxxx xxxxxxxx110110ww wwxxxxxx  110111xx xxxxxxxx
x、u、w可取0或1，其中wwww=uuuuu-1 

41•字节序BOM(Byte Order Mark)
–使用字符(U+FEFF)标识字节序
–Java
中读取UTF-16编码的文件•若文件有BOM，设置为UTF-16即可•若文件无BOM，最好明确设置UTF-16LE还是UTF-16BE•UTF-16LE用的比较多

42GBK：扩展内码规范•收录字符–GB 2312 中的全部汉字、非汉字符号–GB 13000 中的其他CJK 汉字。–以上合计20902 个GB 化汉字–13 个汉字结构符–……•码位分配及顺序–编码范围为8140-FEFE，首字节在81-FE ，尾字节40-FE ，剔除xx7F 一条线–总计23940 个码位，汉字（含部首和构件）21003 个，图形符号883 个，共21886 
。–全部编码分为三大部分：•汉字区。包括：–GB 2312 汉字区。即GBK/2: B0A1-F7FE。收录GB 2312 汉字6763 个，按原顺序排列。–GB 13000.1 扩充汉字区。包括：»GBK/3: 8140-
A0FE。收录GB 13000.1 中的CJK 汉字6080 个。»GBK/4: AA40-FEA0。收录CJK 汉字和增补的汉字8160 个。•图形符号区。包括：–GB 2312 非汉字符号区。即GBK/1: A1A1-
A9FE。其中除GB 2312 的符号外，还有10 个小写罗马数字和GB 12345 增补的符号。
计符号717 个。–GB 13000.1 扩充非汉字区。即GBK/5: A840-
A9A0。BIG-5 非汉字符号、结构符和“○”排列在此区。计符号166 个。•用户自定义区：分为(1)(2)(3)三个小区：–AAA1-
AFFE，码位564 个。–F8A1-FEFE，码位658 个。–A140-
A7A0，码位672 个。限制使用

43GBK编码空间
 
A7
 
717 Graphic Symbol
 846 code positions 
GB2312-
80 
6763 Chinese Char 6768 code 
441 231
 
564 code positions
 
658 
code positions
 FE
 A8-A9
 AAA1
 
A0
 81
 41
 7E 80
 A0 A1
 FE
 
           GBK  /3
 
        GBK  /4 
66 
GBK/5
 
12
GBK/1
 
GBK/2
 
6080 code positions
 
8160 code positions
 
Ideograph character area 
Graphic symbol area 
User defined area
 
Fig. 3. The code position layout of GBK
  

44GB 18030标准
•收录了27484个汉字，总编码空间超过150万个码位
•与GB 2312一脉相承
•是国家标准，在技术上是GBK的超集，并与其兼容，因此
，
GBK将结束其历史使命
•采用单字节、双字节和四字节三种方式对字符编码
–单字节部分使用0x00至0x7F码位(ASCII)。
–双字节部分，首字节码位从0x81至0xFE，尾字节码位分别是0x40
至0x7E和0x80至0xFE。
–四字节部分采用0x30到0x39作为对双字节编码扩充的后缀，其范围为0x81308130到0xFE39FE39
•第一、三个字节编码码位均为0x81至0xFE，
•第二、四个字节编码码位均为0x30至0x39。

45GB 18030

46•记事本的编码
–ANSI ：中文版系统中相当于GB2312/GBK
–Unicode ：UTF-16LE
–Unicode Big Endian : UTF-16BE
–UTF-8

47

编码字符集处理案例
•如下几种情况可能导致zip文件解压后中文文件名乱码
–从Windows上生成的zip文件，在Linux系统上解压缩
–用QQ邮箱批量下载功能生成的zip文件，在Linux系统上解压缩
–Mac OS系统上的zip文件，在Windows上解压缩
•右图是一个实例
48

•问题产生的原因
–不同的操作系统采用的编码字符集不一样
–Zip文件中未包含文件名的编码字符集信息
•解决的方法
–对解压缩软件添加编码字符集检测模块
–识别文件名所用的编码字符集
–将文件名转换为当前操作系统所使用的编码字符集
49

50部分相关命令和函数
•相关的Linux command
–hexdump–C –n 100 file.txt
–iconv–f utf16 –t utf8 file-utf16.txt > file-utf8.txt
•相关函数
–iconv
()
–setlocale()
–mbstowcs()
–wcstombs() 
–WideCharToMultiByte()
–MultiByteToWideChar()

第三节：计算机文字输出技术概述
文本解释引擎
字符字符的图形

文本解释引擎(1)
5
字符
（码点）
字形ID
glyphID

文本解释引擎(1)
•英语、汉语等处理起来比较简单
–一个码点只有一个字形
–不同字符的字形高度
高度可以认为是一致的
–不同字符的字形宽度
宽度有时候不相同
–汉字和英文的文本解释引擎就像活字印刷
活字印刷，找到相应的字形印出来就行了
•蒙古文、藏文、维吾尔文比较特殊
6

字库
•字符码点与glyphID对照表
•字形的宽度、高度、基线信息、字形点阵信息、控制点的信息
•字库：数字化的字模数据库
7

计算机输出方式的变化
•早期的计算机都采用字符设备作为用户的输出设备
–将要输出的字符直接安装(或存储)输出设备(例如，显卡、打印机)中
•此类设备的共性就是字符在物理上很难更改–老式的机械打字机键上的金属或者光学平板那样的条带
•只能输出预先安装(或存储)好的字符–适合字符数少的文字–无法适用于汉字这种字符数巨大的文字
•图形显示和打印设备，特别是图形用户界面的出现改变了这种局面
–通过显现像素、颜色的变化，用一系列的点把字符“画”出来
–这种由黑白像素构成的文字图形就是这个字符的点阵字型
8

点阵字形(1)
•每个点用一个bit位记录
•在笔画上的点记为1，其它点记为0
•点阵字型存储容量(字节) = m / 8 ×n
•m为点阵字型横向的点数，n为点阵字型纵向的点数
•一个16×16点阵的汉字总共需要16/8×16=32个字节表示
9

点阵字形(2)
•在上世纪80年代初，由于显示器分辨率的限制，显示一般采用16×16的汉字点阵
•而当时普遍采用的是24针打印机，用于打印的汉字则采用24×24点阵
•为此，计算机里必须同时存有2套汉字点阵
•16×16点阵通常采用单线体，笔画宽度为1像素
•“畺”（
jiang，古同“疆”）字有9个“横”，加上中间的空隙，纵向需要有18条像素以上才能完全表示出来
•在GB2312-80中的6763个汉字里，有138个汉字需要进行减笔处理
•16×16点阵字形只能适用于低分辨率的显示终端用
•针对激光照排机、图文记录机等高分辨率专业输出设备，96×96、128×128、256×256、512×512、1024×1024的点阵字库
10

点阵字形的缺点
一是低点阵的字型显现效果，特别是打印输出效果较
差，字体不够美观，而随着字型点阵数量的增加，存
储容量急剧增大，采用压缩还原技术虽然可以减少存
储空间开销，但是字体还原的时间开销又会增加；
二是点阵字体缩小、放大效果更差，会产生大量锯齿
状，需要为不同字号预存不同点阵的字库(增加存储成
本），或是在显现过程中引入复杂的“平滑”算法来
消除锯齿(增加时间开销)
11

点阵字形国家标准
•GB5199.1-1985《信息交换用汉字15×16点阵字模集》，本标准所采用的是宋体。•GB5007-1985《信息交换用汉字24×24点阵字模集》，本标准所采用的是宋体。•GB/T14245-1993《信息交换用汉字64×64点阵宋体字模集及数据集》•GB/T14244-1993《信息交换用汉字64×64点阵仿宋体字模集及数据集》•GB/T14243-1993《信息交换用汉字64×64点阵楷体字模集及数据集》•GB/T14242-1993《信息交换用汉字64×64点阵黑体字模集及数据集》•GB/T14717-1993《信息交换用汉字128×128点阵宋体字模集及数据集》•GB/T13444-1992《信息交换用汉字128×128点阵仿宋体字模集及数据集》•GB/T13443-1992《信息交换用汉字128×128点阵楷体字模集及数据集》•GB/T14718-1993《信息交换用汉字128×128点阵黑体字模集及数据集》•GB/T14719-1993《信息交换用汉字256×256点阵宋体字模集及数据集》•GB/T13446-1992《信息交换用汉字256×256点阵仿宋体字模集及数据集》•GB/T13445-1992《信息交换用汉字256×256点阵楷体字模集及数据集》•GB/T14720-1993《信息交换用汉字256×256点阵黑体字模集及数据集》•GB12034-1989《信息交换用汉字32×32点阵(仿宋体)字模集及数据集》•GB12035-1989《信息交换用汉字32×32点阵(楷体)字模集及数据集》•GB12036-1989《信息交换用汉字32×32点阵(黑体)字模集及数据集》•GB12037-1989《信息交换用汉字36×36点阵(宋体)字模集及数据集》•GB12038-1989《信息交换用汉字36×36点阵(仿宋体)字模集及数据集》•GB12039-1989《信息交换用汉字36×36点阵(楷体)字模集及数据集》•GB12040-1989《信息交换用汉字36×36点阵(黑体)字模集及数据集》•GB12041-1989《信息交换用汉字48×48点阵(宋体)字模集及数据集》•GB12042-1989《信息交换用汉字48×48点阵(仿宋体)字模集及数据集》•GB12043-1989《信息交换用汉字48×48点阵(楷体)字模集及数据集》•GB12044-1989《信息交换用汉字48×48点阵(黑体)字模集及数据集》•GB12060-1989《信息处理设备中汉字点阵字模数据的检测方法》12

矢量轮廓字形
•矢量轮廓字型描述技术的核心是用多条有向直线线段逼近字形
用多条有向直线线段逼近字形，并进行封闭处理，最终以一串有序的向量折线来取代文字笔画，对字型的轮廓曲线进行描述。只要这些有序的向量折线与文字笔画轮廓曲线足够近似，由折线构成的轮廓字型就可以达到美观实用的程度
•优点：对字符，特别是汉字的笔画描述更加准确，缩放失真小，数据量也要比点阵字型小，而且可以任意缩放，失真较小，使得文字输出效果得到了很大的改善
•缺点：对于有一定弧度的笔画(如，撇、捺等)的描述比较复杂：如果选
用的线段过长，与笔画的拟合度就会下降，放大时就会出现较为明显的“毛刺”，而选用较短的线段虽然可以提高拟合程度，但是随之而来的就是数据量的增加
•矢量轮廓字型只在上世纪八十年代末、九十年代初的部分产品里得到应用，典型的产品是UCDOS系统，很快就被曲线轮廓字型技术所取代。目前，只在绘图软件、CAD软件中有一定的应用
13

曲线轮廓字形
•用曲线线段逼近字形轮廓
•不仅可以提高拟合程度，而且可以减少数据量
•曲线轮廓字库是以二次曲线和三次曲线逼近字型轮廓的字型描述方法，最具代表性的是：
–美国Adobe公司在1985年开发的PostScript页面描述语言中提供的字型描述技术
–Apple与Microsoft公司合作开发的TrueType字型描述技术
14

贝赛尔曲线(Béziercurve)
•http://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7
%B7%9A
15
一阶二阶
三阶

用贝塞尔曲线描述字体轮廓的原理
16

PostScript字型技术(1)
•PostScript是Adobe公司在1985年为专业数字排版推出的一种页面描述语言
•PostScript规定了一种字型描述方法，其特点是以三次贝塞尔曲线(Bezier curve)线段拟合文字形状，这种技术可以比较完整地保留了文字原有的字形信息，而且可以通过简单的数学运算变形、放大或缩小
•在我国，采用PostScript技术开发的轮廓字库主要用于印刷行业，北大方正、青鸟华光等专业出版系统开发厂商都有自己的PostScript字库产品
•
•王
王选：没有
选：没有PostScript
PostScript就没有北大方正
就没有北大方正！！
17

PostScript字型技术(2)
•PostScript字体根据其组织及用途或目的的不同，又可以分为Type 1、Type 3、OCF、CID等类型：
–Type 1字体只有1字节，因此只能容纳256个字符。它使用Adobe私有的hinting系统，价格昂贵。需要注意的是，很多被称为Type1的字体实际上是Type 3或Type5；
–Type 3与Type 1完全一样，只是没有hints，它只在正常的大小时才美观；
–OCF字体：中文日文等双字节语言可以使用的字体。按照PostScript类型，它属于Type 0 (也就是Type 1或3的组合形式)；
–CID 字体：OCF字体的改良。具有异体字切换功能。按照PostScript类型，多数字体属于Type 9(基于TrueType的CID字体等除外)。
18

TrueType字型技术(1)
•TrueType字型采用二次贝塞尔曲线来描述文字的轮廓外形
•并可以内置点阵字体，保证了字型曲线的光滑并提高了字形的还原速度，同时它还可以任意放大、缩小、变形和旋转而不会影响字体的输出质量
•在文字的显现过程中，TrueType解释器把一个要输出的字符从TrueType文件输出到显现设备上的步骤如下：
–从TrueType字库文件中将该字符的轮廓控制点(以FUnits为单位)读出；
–TrueType解释器中的Scaler将控制点的FUnits坐标转换成像素坐标，并将其放大到应用程序所需要的尺寸；
–TrueType解释器执行该字符描述信息中的相关指令；生成该字符所有轮廓上的点经过栅格调整(Grid-fitted)后的坐标；
–把这些坐标转换成该字符的位图，并输出到相应的设备上。
19

TrueType字体技术(2)
•TrueType既可作打印字体，又可以用作屏幕显示；
•由于TrueType是由字形进行描述，因此与分辨率无关，这样就保证可以按照显现设备的分辨率输出；
•由于采用了曲线及直线来描述字体，因此无论放大或缩小，字符边缘总是光滑的，不会出现锯齿或毛刺。
•相对PostScript字体来说，其质量要差一些。特别是在处理比较小的字号
时，会出现笔画粘连的现象，表现得不是很清楚，习惯上称为“字糊了”。因此，TrueType字库通常用在桌面排版等应用领域，而专业出版通常采用PostScript字体。解决这个问题的方法通常是在TrueType字库中嵌入一个低点阵字库，例如，在宋体TrueType字库中嵌入一个16×16的宋
体点阵字库。当应用软件要求显现小五号以下的字号时，使用点阵字库进行显现。
20

TrueType字体技术(3)
•TrueType字体技术本身的特点而使其具有如下优势：•真正的所见即所得字体：TrueType字体支持几乎所有输出设备，在显示器上的显示和打印机打印的结果是一致的•支持字体嵌入技术：将字形信息嵌入到文件中。保证了接收该文件的计算机可通过装载嵌入在文件中的TTF字体来对文件进行保持原格式，使用原字体打印和修改•操作系统的兼容性：目前MAC OX和Windows、Linux均支持TrueType字体•ABC字宽值：–A宽度为在放置该字符轮廓前的空白间距，B宽度为字符轮廓本身的间距，C为该字符轮廓后方的空白间距–A+B+C即相当于传统的字宽值，同时
A或C间距可以分别为负值，以产生特殊的排字效果–采用
ABC字宽值可避免传统上使用整字字宽值而引起的累积舍入误差。同时可以避免由此产生的行尾的最后一个字符移至下一行，或行左首字符无法对齐等输出时不可预料的后果–排版应用程序在计算一行的累积字宽时所产生的舍入误差，可以分散到整行中每一字符的
A和C间距中，保证了断行的高度准确性和用户定义的左右边界尺寸的精确性；•精确的字体轮廓描述：TTF技术采用2048×2048的格点空间来定义一个传统的字母M空间足够高分辨率率设备使用了
21

PostScript  vs. TrueType
•TrueType采用的是二次贝塞尔函数，与PostScript采用的三次贝塞尔函数相比，结点更多一些，信息更大
–同样一套Times Roman字库，Type 1只需要140KB的存储空间，而TrueType则需要用268KB
–和PostScript字体相比，由于TrueType采用的曲线次数的降低，在保证轮廓曲线光滑性的前提下，大大提高了解释器的工作速度
•TrueType和PostScript字形描述技术都采用了轮廓技术，都是用曲线对轮廓进行描述，而曲线又都是贝塞尔函数。Type 1和TrueType的格式相互
转换会导致一定程度的字形变化，尽管有一些失真，但基本不影响最后的结果
22

OpenType字库技术(1)
•TrueType字体技术中，则要求字体中一个编码只能有一个字型
•阿拉伯文和希伯来文从右向左书写(与存储顺序不同)
•有些文字字母在不同位置上显现形状不同，而这些显现字形在ISO 10646/Unicode标准中并没有编码
23

OpenType字库技术(2)
•OpenType字库技术(简称OTF)是Microsoft和Adobe公司于1996年5月联合推出了一种新的通用字体格式，它集中了TrueType和Type 1两种字形描述技术的特点
•OpenType字体可同时包含TrueType的字体轮廓信息和压缩字体格式(CFF) PostScript字体轮廓信息
•OpenType字体所包括的OpenType布局(Layout)表可供字体设计人员制作
书写特性更加复杂的文字字体。这些表包含了字形的替换、定位、调整和基线定位的信息，有助于文字处理软件提高排版性能，处理具有复杂书写特性的各种文字
•OpenType字体同样能够处理Unicode编码的大字符集
24

OpenType字库技术(3)
•更宽的多平台支持；
•更好地支持国际字符集；
•可以处理复杂文字(Complex Script)；
•更强的字体数据保护；
•字体文件更小，有利于提高发送效率；
•为先进的字体印刷控制提供更多支持。
25

OpenType的高级排印特征
•OpenType布局表
–字型替换表（GSUB：Glyph substitution）
–字型置位表（GPOS:：Glyph positioning）
–字型调整表(JSTF：Justification)
–字型定义表(GDEF：Glyph definition)
–基线数据表(BASE：Baseline)
•其中用于复杂文字处理的最主要的是GSUB和GPOS表
26

OpenType对复杂文字的处理(1)
•字形替换
27

OpenType对复杂文字的处理(2)
•支持连字(ligature)
28

OpenType对复杂文字的处理(3)
•双向(Bi-Direction)文字处理
29

OpenType对复杂文字的处理(4)
•字形重排序(Reorder)
30

OpenType对复杂文字的处理(5)
•字符置位(character positioning)
31

文字输出技术案例一
•问题：Linux某发行版图形界面中文字笔画边缘发虚、模糊
•产生的原因：
–显示器是低分辨率的输出设备
–低分辨率设备使用点阵字形，显示效果更好
–该发行版上未安装点阵字库
•解决办法：
–安装点阵字库
–http://
wenq.org/wqy2/index.cgi?BitmapSong
•请比较下面两幅图(请务必在
请务必在100%
100%的比例下查看
的比例下查看)
–文字显示优化前.png
–文字显示优化后.png
32

文字输出技术案例二(1)
•问题：加粗导致笔画粘连的BUG
•产生的原因：
–使用的字体笔画较粗：•方正超粗黑、黑体等
–加粗算法导致加粗幅度过大
33

文字输出技术案例二(2)
•字形加粗的方法
–点阵字形：平移叠加法
–曲线轮廓字形：平移轮廓控制点
34

文字输出技术案例二(3)
•目标：–加粗与不加粗要有明显区别–不能有笔画粘连
•解决办法：–针对预设的加粗比例–对数十种字体进行测试–比较加粗前后的显示效果–选择合适的加粗比例
–根据汉字的特点–“横”比“竖”多–水平方向和竖直方向采用不同的加粗比例
35
1.文泉驿微米黑2.文泉驿正黑3.文泉驿点阵正黑4.文泉驿等宽微米黑5.文泉驿等宽正黑6.Windows黑体7.方正细黑8.方正行楷9.方正超粗黑10.方正隶书11.方正魏碑12.方正黑体

•最终的效果


第四节：Graphite字库技术概述
Graphite概览
OpenType与Graphite
Graphite编程语言（GDL）
Graphite集成开发环境

Graphite概览
•SIL开发的，跟Unicode兼容的可编程智慧字体构建技术系统（开源）
•支持Graphite的软件：
–Graphite Engine2：Firefox 11+ 、LibreOffice3.4+ 
–Original SilGraphiteEngine：OpenOffice 3.2 、XeTeX0.997+ 、FieldWorks、Paratext、Bloom 、WorldPad
•专为处理小语种而开发，能够处理各种复杂的文字渲染
–contextual shaping （基于上下文的字形变形）
–ligatures （连写字）
–reordering （字形重排序）
–split glyphs （字形切分）
–bidirectionality（双向书写）
–stacking diacritics （变音符号堆叠）
–complex positioning （复杂字形置位）
–…4

Graphite概览
5•复杂渲染举例（1）：Contextual Shaping
–希腊语
–阿拉伯语
–缅甸语

Graphite概览
6•复杂渲染举例（2）：ligatures 
–阿拉伯语
–坦米尔语
–音标音字母

Graphite概览
7•复杂渲染举例（3）：Reordering and Splitting
–孟加拉语
–梵文

Graphite概览
8•复杂渲染举例（4）：Bidirectionality
–阿拉伯语

Graphite概览
9•复杂渲染举例（5）：Diacritic Placement
–罗马语
–阿拉伯语
–泰语

Graphite与OpenType的关系
•OpenType技术特点
–目前最为常用的智能字体技术
–渲染引擎与字体结合较为紧密
–文种相关的行为主要在引擎中进行描述，字体中只需要描述字体特有的细节就行了（哪个字形映射到哪个字形，哪些字形使用哪种精确置位等）
–字体开发简单、工作量小，但是针对不同的操作系统、不同的文种需要开发不同的引擎
•Graphite技术特点
–目前使用较少，主要用于小语种等复杂书写文字
–文字和字体相关的所有行为描述都存储到字体中，使得Graphite字体引擎与具体的文字种类无关
10

Graphite与OpenType的关系
•两者之间的关系
–OpenType的定位是尽量减少具有很大用户和市场的语言的字库制作工作量，而Graphite的设计目标是最大化字库行为的灵活性，因而两者是互为补充而非相互竞争的关系
–同一个应用程序可以同时支持Graphite渲染引擎和OpenType渲染引擎；
–同一个字库可以同时包含Graphite和OpenType特征，应用程序可决定选择使用哪种渲染方式
11

Graphite系统组成
•GDL(Graphite Description Language)
–基于规则的编程语言，用于描述文字系统的行为
•编译器
–编译GDL及其对应字体，生成新版本字体（Graphite-enabled version ）
•渲染引擎
–在文本布局时用Graphite字体辅助文字处理应用
12

Graphite系统架构图
13
GDL程序
编译器：以GDL程序和TrueType字体为输入。
渲染引擎：使用扩展字体，为文字处理程序提供服务。
包含Graphite特性的新版本字体

Graphite字库开发流程
•程序编写：使用Graphite描述语言（GDL）编写程序，用于描述字库的行为。
–辅助工具：make_gdl.pl、FLWriteXml.py 
•程序编译：将GDL程序与字库一起编译，生成新版本的字库。
–输入：原始TrueType字库、GDL程序
–输出：一个新版本的字库，在该字库中，GDL代码被转换存储在一些专用的TrueType表中
•测试与调试：使用支持Graphite的应用程序对新生成的Graphite字库进行测试和调试。
14

Graphite编程语言（GDL）
•GDL用于描述字距调整、连写字替换、字形重排、变音符号堆叠、自动断行、双向书写处理等复杂文字渲染行为；
•GDL文档由一系列的表组成，共包含如下8类
–glyph table（字形定义表）
–substitution table（字形替换表）
–positioning table（字形定位表）
–line-breaking table（断行表）
–feature table（特征表）
–language table（语言表）
–justification-related substitution table（调整相关的替换表）
–name table（命名表）
15

字形定义表（glyph table）
•GDL程序中的必备table，用来定义字形、字形类和字形属性，并为稍后的规则将要使用的字形提供信息
•字形定义：为后续规则要用的字形定义字形标识（glyph identification），字形定义时，可通过如下四种方法获取字形编号
–字体中的实际内部字形编号
–利用Unicode编码，在字体的cmap表中获取获取字形编号
–通过postscript名（附录名）
–通过codepage中的8bit字符编码
16

字形定义表（glyph table）
•字形类定义：一个字形类包含一个或者多个字形

字形定义表（glyph table）
•字形属性定义：Graphite可在字形定义表中定义如下属性
–Attachment points（字形连接点）
–Ligatures（连写属性）
–Directionality （方向属性）
–Breakweight（断行权重）
–Metrics （度量值）
–Mirroring atrributes（镜像属性）

字形替换表（substitution table）
•字形替换表中包含用来描述字形替换、字形重排、字形插入，以及字形删除等规则。一条典型的替换规则包含左手部分、右手部分，以及上下文三个部分。
上例规则所描述的字库行为为：
当小写字母i的后边跟着一个波浪线~时，则i替换为大写的字母I。
左手部分：被替换的字形（类）
右手部分：替换字形（类）
上下文：替换发生的上下文，
_代表被替换字形

字形替换表（substitution table）
•一个替换表由一个或多个pass组成，每个pass的输出作为下一个pass的输入
例子：
pass1：gLowercaseI> gDotlessI/ _ gTildepass2：a  > A /  _  gDotlessI
输入：a  i~
pass1：a  I ~
pass2：A  I ~

字形替换表（substitution table）
•从class中选择元素
•字形顺序重排

字形替换表（substitution table）
•插入和删除
•连写字
将slot3的I移动到辅音之
前的slot1，然后将slot3的字形删除。

字形定位表（positioning table ）
•字形定位表用来对字形进行重新定位和放置
–主要包括字形移动（shifting）、advancing、字距调整（kerning）等操作
–与字形替换表相同，字形定位表由一个或多个pass组成，每个pass的输出作为下一个pass的输入
•字形移动（shifting）
上例的作用是将发音符移动到base字形之上。shift操作并不会改变它之后的字形的屏幕位置。
b
AbCA  C

字形定位表（positioning table ）
•Advancing
为了改变接下来(following)的字形的屏幕位置，则需要修改字形的advace值。有两种advance slot属性用来描述两个字形原点之间的距离：advancewidth（aw），advanceheight（ah）。
这个例子的作用是：将这一行在gOverhanger之后所有字形往右移动overhang的距离，overhang是一个命名的字形属性。

字形定位表（positioning table ）
•kerning 字距调整
有时需要将shift和advancing结合起来使用。
上例中的这种常见操作，它可以通过字距调整属性kern来完成。kern不是一个可读slot属性，它只能被写。

字形定位表（positioning table ）
•样例

Graphite集成开发环境Graide
•Graide是一款官方提供的用于字库制作的集成开发环境，它包含如下功能
–将Graphite table嵌入字体的编译工具
–Graphite字体测试工具
–Graphite规则调试工具
–attachment point编辑器
–定位规则可视化生成器
–针对测试数据的字形序列匹配器；

Graphite集成开发环境Graide

研讨一：编码字符集标准调研
2

3
ASCII
用单个字节表示字符
范围：0~127(2^7 = 128)

4
GB 2312
用0~·127表示表示ASCII字符
用两个字节表示汉字，高位置1
(0xA1~0xFE)

5
GBK
 
A7
 
717 Graphic Symbol
 846 code positions 
GB2312-
80 
6763 Chinese Char 6768 code 
441 231
 
564 code positions
 
658 
code positions
 FE
 A8-A9
 AAA1
 
A0
 81
 41
 7E 80
 A0 A1
 FE
 
           GBK  /3
 
        GBK  /4 
66 
GBK/5
 
12
GBK/1
 
GBK/2
 
6080 code positions
 
8160 code positions
 
Ideograph character area 
Graphic symbol area 
User defined area
 
Fig. 3. The code position layout of GBK
  
用0~·0x7F表示ASCII字符
用两个字节表示汉字，首字节高位置
1 
(0x81~0xFE)，尾字节(0x41~0xFE)

6
GB 18030
扩展到4字节：
一/三字节高位置1 (0x81~0xFE)
二/四字节(0x30~0x39)

7
ISO 10646 / UNICODE
•正则形式(32-bit)
•每个字符表示为一个肆八位序列
•组(Group)八位平面(Plane)八位行八位(Row)   列八位(Cell)
•UCS-4，例如：00 00 00 41 表示字符A (U+00000041, U+0041)
A (U+00000041, U+0041)

8
ISO 10646 / UNICODE
•定义了第0(BMP)、1、2、14平面
•预留第15、16平面作为私用平面
•实际编码空间0到16平面

9
基本多文种平面(BMP)
•全球绝大多数的语言和文字
蒙古文
蒙古文1800
1800-
-18FF
18FF阿拉伯
阿拉伯/ 
/ 维吾尔文：
维吾尔文：0600
0600-
-06FF
06FF藏
藏文
文0F00
0F00-
-0FFF
0FFF
藏文扩充集
藏文扩充集A
A
：
：F300
F300-
-F8FF
F8FF

10
•UCS-4：–是ISO 10646 中的肆八位正则形式，即每个字符编码固定32 位，–由表示组、平面、行、字位的四个八位位组构成•UCS-2：–是ISO 10646 中的双八位BMP 形式，字符编码固定16 位长，只能表示BMP 内
的字符编码，省略了固定为0 的组、平面两个八位位组•UTF-32：–编码范围限于0～10FFFF以保证与UTF-16 的一致性–可以认为UTF-32 等同于UCS-4
•UTF-16：–对BMP 内字符使用16 位编码，与UCS-2 相同–对于超出BMP 的16 个平面(第1～16 平面)使用“替代对”(surrogate pair)机制，
用两个16 位编码表示一个字符–构成替代对的两个编码单元的范围分别是D800～DBFF和DC00～DFFF，编码
空间大小为210×210＝220，相当于16个平面。•UTF-8：–以8 位的字节作为编码基本单位，字符编码长度1～6 字节可变，–对于实际使用的前17 个平面而言，字符编码长度1～4 字节–保证了0～7F 范围内字符与ASCII 一致–相对于其他变长字符编码，UTF-8 成功解决了字符边界的界定问题。

11
•UTF-16
•UTF-8
有效位
 
最小值
(Hex)
 
最大值
(Hex)
 
二进制的位序列 
7
 00000000 0000007F 0vvvvvvv
 
11
 00000080 000007FF 110vvvvv 10vvvvvv 
16
 00000800 0000FFFF
 1110vvvv 10vvvvvv 10vvvvvv
 
21
 00010000 001FFFFF
 11110vvv 10vvvvvv 10vvvvvv 10vvvvvv
 
26
 00200000 03FFFFFF
 111110vv 10vvvvvv 10vvvvvv 
10vvvvvv 10vvvvvv 
31
 04000000 7FFFFFFF 1111110v 10vvvvvv 10vvvvvv 10vvvvvv 10vvvvvv 10vvvvvv
 
 
Unicode码点（Bit）UTF-16编码结果（Bit）
BMP平面xxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxx
非BMP平面000uuuuu xxxxxxxx xxxxxxxx110110ww wwxxxxxx  110111xx xxxxxxxx
x、u、w可取0或1，其中wwww=uuuuu-1 

Unicode码点与UTF-16的转换
•（1）将Unicode码点codepoint转换为UTF-16编码：•// constants•constUTF32 LEAD_OFFSET = 0xD800 -(0x10000 >> 10);•constUTF32 SURROGATE_OFFSET = 0x10000 -(0xD800 << 10) -0xDC00;•// computations•UTF16 lead = LEAD_OFFSET + (codepoint>> 10);•UTF16 trail = 0xDC00 + (codepoint& 0x3FF);
•（2）将UTF-16编码转换为Unicode码点codepoint：•// constants•constUTF32 LEAD_OFFSET = 0xD800 -(0x10000 >> 10);•constUTF32 SURROGATE_OFFSET = 0x10000 -(0xD800 << 10) -0xDC00;•// computations•UTF32 codepoint= (lead << 10) + trail + SURROGATE_OFFSET;
12
Unicode码点（Bit）UTF-16编码结果（Bit）
BMP平面xxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxx
非BMP平面000uuuuu xxxxxxxx xxxxxxxx110110ww wwxxxxxx  110111xx xxxxxxxx
x、u、w可取0或1，其中wwww=uuuuu-1 

Unicode码点与UTF-8的转换
•Unicode码点转UTF-8
–根据编码范围，确定需要的字节数n
–从低位往高位，每次取6位xxxxxx，最高两位10，形成10xxxxxx，共n
-1个
–以n确定首字节中有n位1，后续跟1位0，从Unicode码点取剩余的低位数字
•UTF-8转Unicode码点
–根据首字节确定当前字符使用了几个字节表示
–将各个字节除标志位以外的位，按高低顺序连在一起，该数字的值即为Unicode码点
13

14
BOM
•字节序BOM(Byte Order Mark)
–使用字符(U+FEFF)标识字节序
–Java
中读取UTF-16编码的文件•若文件有BOM，设置为UTF-16即可•若文件无BOM，最好明确设置UTF-16LE还是UTF-16BE•UTF-16LE用的比较多

编码空间容量
•ASCII: 
–128
•GB2312
–(FE-A0)^2 + 128 = 94*94 + 128 = 8964
•GBK
–(FE-40) * (FE-80) + 129 = 190 * 126 + 128 = 24068
•GB 18030
–GBK + 1587600 ≈ 161万
•Unicode
–2^16 * 17 = 1114112 ≈ 110万
15

Unicode编码的优点
•在同一个编码空间中对全世界所有的文字进行统一编码
•BMP基本多文种平面可以表达全球绝大多数文字
•BMP范围内，可以用两个字节表示一个字符，是等长编码，方便程序处理
•使用UTF-16编码作为程序内码，大部分时候是等长编码，方便程序处理，又节省存储空间
•UTF-8可以兼容ASCII，表示英文时，与ASCII完全一致，原有C程序可以继续使用
•GB18030的变长编码处理起来有些麻烦，不方便作为内码使用
•Surrogate Pair是UTF-16编码中用于表示BMP以外平面字符的方式，
采用两个编码单元表示一个字符，首单元取值D800~DBFF，尾单元取值DC00~DFFF
16

对研讨问题1的回答
•从字符表示方式、编码空间容量、多民族语言字符兼容性和便捷性等方面比较ASCII、GB2312、GBK、GB18030、Unicode等字符集的差异和优缺点？
–ASCII只能表示英文
–因表示（更多）汉字的需求，依次产生了GB2312、GBK、GB18030，
编码空间越来越大
–为了表示全球所有文字，产生了Unicode
–在字汇方面，Unicode与GB18030是兼容的
–优缺点：•Unicode：全世界通用•GB18030：国家安全的考虑
17

对研讨问题2的回答
•UTF-8、UTF-16、UTF-32、UCS2、UCS4之间的主要差异是什么？
–UTF-32 == UCS4
–BMP内：UTF-16 == UCS2，BMP外：UTF-16 >UCS2
–编码长度：UTF-32定长码，UTF-16在BMP内定长，UTF-8变长
•这些编码适合的应用场景，说明理由？
–若只处理英文：UTF-8 == ASCII
–内存处理时：使用UTF-16，定长处理全球多数文字，满足需求，又不浪费很多空间
–外部文件交换时：UTF-8，可以兼容ASCII，兼容英文和半角数字


研讨二：编程语言中文字处理相关功能调研
2

C语言——字符表示
•单个字符的表示
–char：8单字节
–wchar_t：双字节（Windows），四字节（Linux）
•字符串的表示，用数组表示
–char  str[256]：适合存储ASCII、GB2312/GBK/GB18030、UTF-8编码的文本
–wchar_twstr[256]：适合存储UTF-16编码的文本（Windows）/UTF-32(Linux)
•字符串处理相关函数
3

C语言——文件读写
•文件读写相关的函数
4

C语言——编码字符集检测
•文本文件的编码字符集检测步骤•（仅供参考，还有其他方案）•打开文件–FILE * fp= fopen()•读入一段数据到内存–char  buf
[256];–fread(buf
, sizeof
(char), 256, fp);•使用检测规则检测编码，规则如下：–判断前三个字节是否EF BB BF，若是，则为UTF-8编码，否则，–判断前两个字节是否FEFF，若是，则为UTF-16BE编码，否则，–判断前两个字节是否FFFE，若是，则为UTF-16BE编码，否则，–判断是否存在XX 00序列，•如果有，根据00在数组中的索引值，若索引值为偶数，则为UTF-16BE编码，若为奇数则为UTF-16BE编码，否则，–判断字节之间是否满足UTF-8编码的约束关系，满足则为UTF-8编码，否则，–判断字节之间是否满足GBK编码的约束关系5

C语言——编码字符集转换
•size_t mbstowcs (
–wchar_t* dest, 
–const char* src, 
–size_t max);
•size_t wcstombs (
–char* dest, 
–const wchar_t* src, 
–size_t max);
•char* setlocale(
–intcategory, 
–constchar* locale);
6#include <stdlib.h>#include <stdio.h>
void main( void ){inti;char    *pmbnull= NULL;char    *pmbhello= (char *)malloc( MB_CUR_MAX );wchar_t*pwchello= L"Hi";wchar_t*pwc= (wchar_t*)malloc( sizeof
( wchar_t));
printf
( "Convert to multibytestring:\n" );
i= wcstombs
wcstombs( pmbhello, pwchello, MB_CUR_MAX );printf
( "\tCharactersconverted: %u\n", i);printf
( "\tHexvalue of first" );printf
( " multibytecharacter: %#.4x\n\n", pmbhello);
printf
( "Convert back to wide-character string:\n" );
i= mbstowcs
mbstowcs( pwc, pmbhello, MB_CUR_MAX );printf
( "\tCharactersconverted: %u\n", i);printf
( "\tHexvalue of first" );printf
( " wide character: %#.4x\n\n", pwc);}

C语言——词典存储和检索
•词典存储：二维数组
–UTF-8/GBK：•char * dict[]•char dict[][]
–UTF-16：•wchar_t* dict[]•wchar_tdict[][]
–UTF-16：•unsigned short * dict[]•unsigned short dict[][]
•词典检索：二分查找
7

C语言——词典按词频排序
•词典条目
–structitem {intvalue; //
词频char *pWord; //
词语};
•词典
–structitem dict[1024];
•排序
–#include <stdlib.h> /* qsort*/
–qsort(dict, 1024, sizeof
(structitem), value_comp
value_comp);
8•排序函数定义intvalue_comp(constvoid* a, constvoid* b)
{item* pa = (item*) a;
item* pb= (item*) b;
if (pb->value < pa
->value)return 1;
else if (pa
->value < pb->value)return 
-1;return 0;}

C++/STL——字符表示
•单个字符的表示：同C语言
•字符串的表示
–string：适合存储ASCII、GB2312/GBK/GB18030、UTF-8编码的文本
–wstring：适合存储UTF-16编码的文本（Windows）/UTF-32(Linux)
–basic_string<unsigned short>：适合存储UTF-16编码的文本
•字符串处理相关函数
9•string类的构造函数：•string(constchar *s);    //用c字符串s初始化•string类的字符操作：•operator[]和at()均返回当前字符串中第n个字符•constchar *c_str()const;//返回一个以null终止的c字符串•string的特性描述:•intsize()const;        //返回当前字符串的大小•intlength()const;       //返回当前字符串的长度•boolempty()const;        //当前字符串是否为空•string的连接：•string &operator+=(conststring &s);//把字符串s连接到当前字符串的
结尾•string &append(conststring &s);    //同operator+=()•string的比较：•booloperator==(conststring &s1,const string &s2)const;//比较两个字
符串是否相等•运算符">","<",">=","<=","!="均被重载用于字符串的比较；•intcompare(conststring &s) const;//比较当前字符串和s的大小•compare函数在>时返回1，<时返回-1，==时返回0  •string的子串：•string substr(intpos= 0,int n = npos) const;//返回pos开始的n个字符组
成的字符串•string类的查找函数：•intfind(conststring &s, intpos= 0) const; //从pos开始查找字符串s在
当前串中的位置•//查找成功时返回所在位置，失败返回string::npos的值•intrfind(conststring &s,intpos= npos) const; //从pos开始从后向前查
找•string类的替换函数：•string &replace(intp0, intn0,const string &s);//删除从p0开始的n0个字符，然后在
p0处插入串s

C++/STL——文件读写
•文件读写相关类和函数
•ofstream
:Stream class to write on files
•ifstream
:Stream class to read from files
•fstream
:Stream class to both read and write from/to files.
10

C++/STL——编码字符集检测与转换
•文本文件的编码字符集检测步骤–参考C语言–文件读写使用ifstream–字符串存入string类型–检测规则与C语言中的一致•编码字符集转换–C语言：支持Windows和Linux•size_tmbstowcs();•size_twcstombs();•char* setlocale();–Linux•iconv_ticonv_open(constchar* tocode,constchar* fromcode);•size_ticonv(iconv_tcd,char** inbuf,size_t* inbytesleft,char** outbuf,size_t* outbytesleft);•inticonv_close(iconv_tcd);–Windows (详见MFC)•
•MultiByteToWideChar
MultiByteToWideChar•
•WideChar
WideCharTo
ToMultiByte
MultiByte
11
iconv_tcd=iconv_open("GBK","UTF-8");char* outbuf
=(char*)malloc(inlen*4);bzero(outbuf,inlen*4);char* in=inbuf
;char* out=outbuf
;size_toutlen=inlen*4;iconv( cd, &in, (size_t*)&inlen, &out, &outlen);outlen=strlen(outbuf
);printf
("%s\n",outbuf
);free(outbuf
);iconv_close(cd);
wstringUTF8ToUnicode( conststring& str){intlen= 0;len= str.length();intunicodeLen= ::MultiByteToWideChar( CP_UTF8,0, str.c_str(), -1, NULL, 0 ); wchar_t*  pUnicode; pUnicode= new  wchar_t[unicodeLen+1]; memset(pUnicode,0,(unicodeLen+1)*sizeof
(wchar_t)); ::MultiByteToWideChar( CP_UTF8,0, str.c_str(), -1, (LPWSTR)pUnicode, unicodeLen); wstringrt; rt= ( wchar_t* )pUnicode;delete  pUnicode;return  rt; }

C++/STL——词典存储和检索
•词典存储：二维数组–typedefstd:map
std:map<string, int> MSI;–MSI name2num;
•词典检索：
–word = “one”
–name2num[word] += 2;
•词语是否存在
–MSI::iterator itor= name2num.find( word )
–if (itor==name2num.end()){
–}else{
–}
12typedefmap<string, int> MSI;MSI name2num;name2num.insert(MSI::value_type("one", 1));name2num.insert(MSI::value_type("two", 2));name2num.insert(MSI::value_type("three", 3));int n3 = name2num
name2num["one"] 
["one"] + name2num
name2num["two"];
["two"];cout<< n3 << " called ";for (MSI::const_iteratori= name2num.begin();i!= name2num.end(); ++i)if ((*i).second == n3){cout<< (*i).first << endl;}

C++/STL——词典按词频排序
•词典条目
–
–struct
structI
Item {intvalue; //
词频wstringstrWord; //
词语};
•词典
–vector<structItem *> items;
•排序
–std::sort(items.begin(),items.end(),comparisonFunction
comparisonFunction);
13
•排序函数定义inline boolcomparisonFuncion
comparisonFuncion( item *  lhs,item* rhs){return lhs->value  <  rhs->value;}

VC++/MFC——字符表示
•单个字符的表示：
–char，wchar_t，TCHAR
•字符串的表示
–CStringA：•适合存储ASCII、GB2312/GBK/GB18030、UTF-8编码的文本
–CStringW：•适合存储UTF-16编码的文本（Windows）/UTF-32(Linux)
–CString:•根据VC的工程配置被宏定义为CStringA
或CStringW
•字符串处理相关函数
14•CStringcsStr("ABCDEF中文123456");
•intGetLength( ) const;•void MakeReverse( );•void MakeUpper( );•void MakeLower( );•intCompare( LPCTSTR lpsz) const;•intCompareNoCase( LPCTSTR lpsz) const;•intDelete( intnIndex, intnCount= 1 )•intInsert( intnIndex, LPCTSTR pstr)•intRemove( TCHAR ch);•intReplace( TCHAR chOld, TCHAR chNew);•intReplace( LPCTSTR lpszOld, LPCTSTR lpszNew);•void TrimLeft( LPCTSTR lpszTargets);•void TrimRight( LPCTSTR lpszTargets);•void Empty( );•BOOL IsEmpty( ) const;•intFind( LPCTSTR pstr, intnStart) const;•intFindOneOf
( LPCTSTR lpszCharSet) const;•CStringSpanExcluding( LPCTSTR lpszCharSet) const;•CStringSpanIncluding( LPCTSTR lpszCharSet) const;•intReverseFind( TCHAR ch) const;•void Format( LPCTSTR lpszFormat, ... );•TCHAR GetAt( intnIndex) const;•void SetAt( intnIndex, TCHAR ch);•CStringLeft( intnCount) const;•CStringRight( intnCount) const;•CStringMid( intnFirst, intnCount) const;

VC++/MFC——文件读写
•文件读写相关类和函数
–CFile: •Open(),Read(),Write(),Close()
–CStdioFile: •Open(),Read(),Write(),Close()•逐行读取：ReadString()•逐行写入：WriteString()
•文件读写时进行编码转换
15
FILE
FILE* rFile;if( _wfopen_s(&rFile, strPath, L"r
, ccs=UTF
ccs=UTF-
-8
8") == 0 ) {CStdioFile
CStdioFilefile(rFile);CStringstrLine;CStringstrText;
while( file.ReadString
ReadString( strLine) ){strText+= strLine+ _T("\r\n");}file.Close();}

VC++/MFC——编码字符集检测与转换
•文本文件的编码字符集检测步骤–参考C语言–文件读写使用CFile/CStdioFile–字符串存入CStringA类型–检测规则与C语言中的一致•编码字符集转换，Windows–intMultiByteToWideChar
MultiByteToWideChar(–_In_       UINT CodePage,–_In_       DWORD dwFlags,–_In_       LPCSTR lpMultiByteStr,–_In_       intcbMultiByte,–_Out_opt_  LPWSTR lpWideCharStr,–_In_       intcchWideChar–);–intWideCharToMultiByte
WideCharToMultiByte(–_In_       UINT CodePage,–_In_       DWORD dwFlags,–_In_       LPCWSTR lpWideCharStr,–_In_       intcchWideChar,–_Out_opt_  LPSTR lpMultiByteStr,–_In_       intcbMultiByte,–_In_opt_   LPCSTR lpDefaultChar,–_Out_opt_  LPBOOL lpUsedDefaultChar–);16
CStringUTF8ToUnicode( conststring& str){intlen= 0;len= str.length();intunicodeLen= ::MultiByteToWideChar( CP_UTF8,0, str.c_str(), -1, NULL, 0 ); wchar_t*  pUnicode; pUnicode= new  wchar_t[unicodeLen+1]; memset(pUnicode,0,(unicodeLen+1)*sizeof
(wchar_t)); ::MultiByteToWideChar( CP_UTF8,0, str.c_str(), -1, (LPWSTR)pUnicode, unicodeLen); CStringrt; rt= ( wchar_t* )pUnicode;delete  pUnicode;return  rt; }

VC++/MFC——词典存储和检索
•词典存储–CStringArray–CMap<CString, LPCTSTR, int, int> typeMap;
•词典检索
–CStringArray：二分查找
–CMap：Hash查找
•词语是否存在
–CStringArray：二分查找
–CMap：Lookup()函数
17
//.h
CMap<CString, LPCTSTR, int, int> typeMap;//.
cpp
typeMap.SetAt(_T("ONE"),1);
typeMap.SetAt(_T("TWO"),2);typeMap.SetAt(_T(“一”),1);
typeMap.SetAt(_T(“二”),2);
intnValue= 0;
BOOL ret = typeMap.Lookup(_T(“ONE”), nValue); //TRUE
ret = typeMap.Lookup(_T("THREE"), nValue); //FALSE
ret = typeMap.Lookup(_T("TWO"), nValue);//TRUE
ret = typeMap.Lookup(_T(“一”), nValue);//TRUE
ret = typeMap.Lookup(_T(“二"), nValue);//TRUE

VC++/MFC——词典按词频排序
•词典条目
–
–class
classI
Item {intvalue; //
词频CString
CStringstrWord;
–};
•词典
–Item dict[1024];
•排序
–#include <stdlib.h> /* qsort*/
–qsort(dict, 1024, sizeof
(item), value_comp
value_comp);
18•排序函数定义intvalue_comp(constvoid* a, constvoid* b)
{item* pa = (item*) a;
item* pb= (item*) b;
if (pb->value < pa
->value)return 1;
else if (pa
->value < pb->value)return 
-1;return 0;}
也可以使用std::sort()

Qt——字符表示
•单个字符的表示：
–QChar
•字符串的表示
–QString：•适合存储UTF-16编码的文本
•字符串处理相关函数
–一系列好用的函数
–支持正则表达式
–支持编码字符集转换
19
•QString()•QString(constQChar*, int)•append(constQString&) : QString&•at(int) const: constQChar•capacity() const: int•chop(int)•clear()•compare(constQString&, constQString&, Qt::CaseSensitivity) : 
int•contains(constQString&, Qt::CaseSensitivity) const: bool•contains(constQRegExp&) const: bool•contains(QRegExp&) const: bool•count(constQString&, Qt::CaseSensitivity) const: int•count(constQRegExp&) const: int•count() const: int•endsWith(constQString&, Qt::CaseSensitivity) const: bool•fill(QChar, int) : QString&•indexOf
(constQString&, int, Qt::CaseSensitivity) const: int•insert(int, constQString&) : QString&•isEmpty() const: bool•isNull() const: bool•isRightToLeft() const: bool•lastIndexOf
(constQString&, int, Qt::CaseSensitivity) const: int•left(int) const: QString•leftJustified(int, QChar, bool) const: QString•leftRef
(int) const: QStringRef•length() const: int•localeAwareCompare(constQString&) const: int•mid(int, int) const: QString•number(long, int) : QString

Qt——文件读写和编码转换
•文件读写相关类和函数–QTextStream
–QFile
( constQString&name ) –boolexists () const–boolremove ()–boolopen ( intm )–void close ()–Offset size () const–Q_LONG readBlock( char * p, Q_ULONG len)–Q_LONG readLine
readLine( QString& s, Q_ULONG maxlen)
•读文件的实例
20
QStringListlines;QFile file( "file.txt" );if ( file.open( IO_ReadOnly) ) {QTextStreamstream( &file );QStringline;intn = 1;while ( !stream.eof
() ) {line = stream.readLine
stream.readLine()
(); // 不包括“\n”的一行文本printf
( "%3d: %s\n", n++, line.latin1() );lines += line;}file.close();}

Qt——编码字符集检测与转换
•文本文件的编码字符集检测步骤–参考C语言–文件读写使用QFile–字符串存入QByteArray类型–检测规则与C语言中的一致
•字符串一级的编码字符集转换
•文件读写时的编码转换
21
fromAscii(constchar *, int) : QStringfromLatin1(constchar *, int) : QStringfromLocal8Bit(constchar *, int) : QStringfromRawData(constQChar*, int) : QStringfromStdString(conststd::string &) : QStringfromStdWString(conststd::wstring&) : QStringfromUcs4(constuint*, int) : QStringfromUtf8(constchar *, int) : QStringfromUtf16(constushort*, int) : QStringfromWCharArray(constwchar_t*, int) : QString
#include <QtCore>intmain(){QFile file("s.txt");if (!file.open(QIODevice::ReadOnly| QIODevice::Text)){return -1;}QTextStreamin(&file);in.setCodec
in.setCodec("UTF
("UTF-
-8"); //
8"); //请注意这行
请注意这行while(!in.atEnd()){QStringline = in.readLine();qDebug() << line;}}

Qt——词典存储和检索
•词典存储
–QHash<QString, int> hash;
–QMap<QString, int> map;
•词典检索
–QHash：Hash查找
•词语是否存在
–find(constKey &key)
22
//下面代码中可将QHash替换为QMap
QHash<QString, int> hash;
hash["one"] = 1;hash["three"] = 3;hash["seven"] = 7;hash.insert("twelve", 12);
intnum1 = hash["thirteen"];intnum2 = hash.value("thirteen");
inttimeout = 30;if (hash.contains("TIMEOUT"))timeout = hash.value("TIMEOUT");

Qt——词典按词频排序
•词典条目
–
–class
classI
Item {intvalue; //
词频Q
QString
StringstrWord;
–};
•词典
–QList<Item> list;
•排序
–
–qSort
qSort(list.begin(), list.end(), value_comp);
23•排序函数定义boolvalue_comp(constI
Item &s1, constI
Item &s2){return s1.getValue() < s2.value.getValue();}

Java——字符表示
•单个字符的表示：
–Char
•字符串的表示
–String：•适合存储UTF-16编码的文本（Windows）
•字符串处理相关函数
–一系列好用的函数
–支持正则表达式
–支持编码字符集转换
24
•char charAt(intindex)•intcompareTo(String anotherString)•intcompareToIgnoreCase(String str)•String concat(String str)•booleanendsWith(String suffix)•booleanequalsIgnoreCase(String anotherString)
•
•byte
byte[] 
[] getBytes
getBytes(String 
(String charsetName
charsetName)
)
•inthashCode()•intindexOf
(String str, intfromIndex)•intlastIndexOf
(String str, intfromIndex)•intlength()
•
•boolean
booleanmatches(String regex)
matches(String regex)•
•String 
String replaceAll
replaceAll(String regex, String replacement
(String regex, String replacement•
•String 
String replaceFirst
replaceFirst(String regex, String replacement)
(String regex, String replacement)•
•String[] split(String regex, 
String[] split(String regex, int
intlimit)
limit)
•booleanstartsWith(String prefix, inttoffset)•String substring(intbeginIndex, intendIndex)•char[] toCharArray()•String toLowerCase()•String toUpperCase()•String trim()

Java——文件读写与编码转换
public class UTF8Test {  
public static void main(String[] args) throws IOException{  
File f  = new File("./utf.txt");  
FileInputStreamin = new FileInputStream(f);  
// 指定读取文件时以UTF-8的格式读取
BufferedReaderbr= new BufferedReader(new InputStreamReader(in, "UTF
, "UTF-
-8"));  
8"));  
String line = br.readLine();  
while(line != null)  
{  
System.out.println(line);  
line = br.readLine();  
}  
}  
}
25

Java——编码字符集检测与转换
•文本文件的编码字符集检测步骤–参考C语言–文件读写使用File和FileInputStream–字符串存入byte[]类型–检测规则与C语言中的一致
•字符串一级的编码字符集转换
26
String original = new String("A" + "\u00ea" + "\u00f1" + "\u00fc" + "C");try {byte[] utf8Bytes = original.getBytes
getBytes("UTF8");
("UTF8");byte[] defaultBytes= original.getBytes();String roundTrip= new String(utf8Bytes, "UTF8");
String(utf8Bytes, "UTF8");System.out.println("roundTrip= " + roundTrip);System.out.println();} catch (UnsupportedEncodingExceptione) {e.printStackTrace();}

Java——词典存储和检索
•词典存储
–HashMap;
–HashTable
•词典检索
–Hash查找
•词语是否存在
–HashMap•containsKey()
–HashTable•get() != null
27
Map 
Map map
map= new 
= new HashMap
HashMap();
();map.put("RajibSarma","100");map.put("RajibSarma","200");//The value "100" is replaced by "200".map.put("SazidAhmed","200");
Iterator iter= map.entrySet().iterator();while (iter.hasNext()) {Map.Entryentry = (Map.Entry) iter.next();Object key = entry.getKey();Object val= entry.getValue();}
Hashtable<String, Integer>numbers  = new Hashtable<String, Integer>();numbers.put("one", 1);numbers.put("two", 2);numbers.put("three", 3);Integer n = 
Integer n = numbers.get
numbers.get("two");
("two");if (n != null) {System.out.println("two = " + n);}

Java——词典按词频排序
•
•词典
词典条目和比较函数
条目和比较函数public class WordTableimplements Comparable<WordTable>{    private String word;
private String word;private String 
private String num
num;
;
public intcompareTo
compareTo(WordTablect) {inti= this.num.compareTo(ct.num);if(i== 0) { return this.word.compareTo(ct.word);} else {return i; }}}
28
•
•具体排序调用
具体排序调用public class wordCodeRank{public static void main(String[] args) {TreeSet<WordTable> ts= new TreeSet<WordTable>();getWordTable(ts, "./wordCode.txt");createWordTable(ts, "./wordCodeRank.txt");                        }public static void getWordTable(TreeSet<WordTable> ts, String fileName){        try{//读取输入文件中的词典}catch(IOExceptione){e.printStackTrace();}            }public static void createWordTable(TreeSet<WordTable> ts, String fileName){            try{            BufferedWriterbw= new BufferedWriter(new FileWriter(new File(fileName)));            Iterator<
Iterator<WordTable
WordTable> it = 
> it = ts.descendingIterator
ts.descendingIterator();
();while(
while(it.hasNext
it.hasNext()){
()){WordTable
WordTablect
ct= 
= it.next
it.next();
();bw.write(ct.getWord()+" "+ct.getNum());bw.newLine();bw.flush();}bw.close();            }catch(IOExceptione){e.printStackTrace();}            }}

Python——字符表示
•字符串的表示
–str•适合存储ASCII、GB2312/GBK/GB18030、UTF-8编码的文本
–unicodeobject•适合存储UTF-16编码的文本
•字符串处理相关函数
29

Python——文件读写
•普通文件读写vs. 带编码转换的读写
30
#coding:utf
-8  f = open('
open('poem.txt','r
poem.txt','r')  
')  result = list()  for line in open('poem.txt'):  line = f.readline()  print line  result.append(line)  print result  f.close()
import codecsf = codecs.open
codecs.open("pru_uni.txt", "w", "utf
("pru_uni.txt", "w", "utf
-
-8")
8")txt = unicode("campeón\n", "utf
-8")f.write(txt)f.write(u'中文\n')f.close()

Python——编码字符集转换
31
>>> tilde='~'>>> tilde.encode('utf_8')'~'>>> u16 = u'\u0456'>>> s = u16.encode('utf_8')
u16.encode('utf_8')>>> s'\xd1\x96'>>> s.decode
s.decode('utf_8')
('utf_8')u'\u0456'>>> u32 = u'\U000E1234'>>> s = u32.encode('utf_8')
u32.encode('utf_8')>>> s'\xf3\xa1\x88\xb4'>>> s.decode
s.decode('utf_8')
('utf_8')u'\U000e1234'

Python——词典存储和检索
•词典存储
–Dictionaries
32
>>> tel= {'jack': 4098, 'sape': 4139}>>> tel['guido'] = 4127>>> tel{'sape': 4139, 'guido': 4127, 'jack': 4098}>>> tel['jack']4098>>> del tel['sape']>>> tel['irv'] = 4127>>> tel{'guido': 4127, 'irv': 4127, 'jack': 4098}>>> tel.keys()['guido', 'irv', 'jack']>>> 'guido' in
intelTrue
True
>>> dict(sape=4139, guido=4127, jack=4098){'sape': 4139, 'jack': 4098, 'guido': 4127}

Python——词典按词频排序
•方法1：
–dictionary = dict(siis= 1, sana= 2, 
joka= 3, tuli= 4, aina= 5)
–for word in sorted(dictionary, key=dictionary.get, reverse=True):
–print(word, dictionary[word])
•方法2：sorted([(value,key) for (key,value) in mydict.items()])
•方法3：
–import collections
–Player = collections.namedtuple('Player', 'score name')
–d = {'John':5, 'Alex':10, 'Richard': 7}
–worst = sorted(Player(v,k) for (k,v
) in d.items())
–best = sorted([Player(v,k) for (k,v
) in d.items()], reverse=True)
33

小结
•研讨1：了解了各种编码字符集的情况
•研讨2：了解了各种编程语言中文本处理的数据结构和功能函数


研讨三：Graphite与OpenType技术调研
2

OpenType字库技术
•Adobe公司与微软在1995年合作开发的新一代跨平台的字体技术.，
以国际标准编码（Unicode）为基础,集中了TrueType 与Type1字型描述信息,并融合了PostScript字体技术。
•Open Type字体在支持TrueType体系结构的基础上增加了一些高级排印特征,这些特征对复杂文本的处理提供了很好的支持，相应的特征数据放在OpenType 布局表中。
•OpenType布局表
–字型替换表（GSUB：Glyph substitution）
–字型置位表（GPOS:：Glyph positioning）
–字型调整表(JSTF：Justification)
–字型定义表(GDEF：Glyph definition)
–基线数据表(BASE：Baseline)
3

OpenType字库技术
•OpenType布局表中用于复杂文字处理的最主要的是GSUB和GPOS表
–字型替换表（GSUB：Glyph substitution）
•包含字形替换信息，包括一对一、一对多（连体字形分解）、
多对一（连体字形）以及上下文相关的替换
–字型置位表（GPOS：Glyph positioning）
•提供字型置位和黏着的信息，支持单一字形或两个字形之间位置调整、黏着点位置信息定义、依据上下文的字形置位等操作
•OpenType技术中，大多数的文字行为在显示引擎中进行描述，在字体
的GSUB和GPOS表中通常只需要描述诸如“哪个字形映射到哪个字形”、“哪个字形使用哪种重定位方式”等字体特有的细节
–字库制作简单
–字库与引擎结合紧密
4

Graphite字库技术
•SIL开发的，跟Unicode兼容的可编程智慧字库构建技术系统（开源
），专为复杂文本显示而设计。
•Graphite字库在TrueType字体格式基础之上，新增了若干个自用的新表。
它允许各种智慧构建字体规则，包括：连体字、字形替换、字形插入、字形重排、标音符定锚、缩进及对齐等。
–字库开发者使用Graphite提供的GDL编程语言所编写的复杂文本布局规则，将被编译到字库的这些Graphite自用表中。
•Graphite将所有字体构建信息直接储在字库里，要显示使用Graphite构建的智慧字体，文字处理程序只需要提供对标准Graphite引擎的支持，而无需知道有关文字的书写方式。
–字库对引擎依赖度较低
5

汉字
•字符数量超级多
•方块字，每个字的宽度和高度都一样（活字印刷），
•显示的时候，一行中每个汉字的坐标可以方便地提前计算
6
区块编码范围字符数累计备注
CJK基本集4E00-9FA52090220902Unicode 4.09FA6-9FCB2620928Unicode 4.1CJK 扩A3400–4DB5658227510CJK 扩B20000–
2A6D64271170221CJK 扩C2A700–2B734414974370CJK 扩D2B740–
2B81D22174591

英文
•所有的编码字符集都兼容ASCII
•字符宽度：
W > I
•显示时从左向右依次排列即可
7

蒙古文文本示例
ē˃ʢĖ
 
ī˃Ğʬć
 
̀ŲʒĞ˻
 
űʒɆĄʗĬő ʫĬ˄
 
Ź˃ĄʌĄő Į
 
ǵĄʌĬȽ
 
īǶĄɆĄő Į
 
ʲĽĞʓ ʫľ˄
 
ʋĕ˃ɐő
 
ŽʒĬȿʗĄő
 
ʖĄĞő
 
ʡĵ˃Ķʓ ʡľ
 
ȂʌĕȟŋĞɐő
 
Ź˃ĄʌĄő
 
ƍʒľɎ᠃
 
ʡĕ˃Ė
 
Ź˃ĄʌĄő ʫĬ˄
 
ʖĕʨȋʓ ʫĬ˄
 
ʡĄɆĄʒĄǶĮ
 
ŋĕ˃ĕʢŀ
 
ŋĞɐő
 
ǵĄʢĬȿʢĄĠ
 
ƍʒľɎ᠃
 
ʡĕ˃Ė
 
ǵĦʹĄ˄ ăʯć
 
ŋĞɐő
 
ȒŶɮő
 
ʡĵ˃ĶʳľȡĠ᠃
 
ʡĕ˃Ė
 
ȒŶɮő
 
ĝŎĮ
 
ļʯľɮȃő ēʯĖ
 
ɏɐő
 
ĥʹĬʢĮ
 
ʸĕȃʘ ľő
 
ʸĄƂʬĄʓ ĞʽĄ˄
 
ʸĄƂȿʯĠŋĞɐő
 
ŽʒŲĠ᠃
 
ʡĕōʬĖ
 
ēȁ
 
ĝŎĮ
 
ăˀ ċ
 
ēŎĖ
 
ȒŶɮő
 
ʡĵ˃Ķɐʦ
 
ʖĄʯć
 
ʸĕȃʘ ľő
 
ʸĄƂʬĄʓ ĞʽĄ˄
 
ʸĄƂȿʯĠ
 
ɏɐő
 
ĥʹĬʢĮƍȟ ʼĞő
 
ʡĬʒć᠃
 
ʋĄɆĄʦ
 
ŋĞɐő
 
ʲĄʹĄɂ ċ ʡĮ
 
ƁĠ ʶ ċ
 
Ȃʌĕʳŀ᠃
 
ɏĞɌʗĕő
 
Ȃʌĕő
 
ŋĕ˄ ę
 
Ĵȿɮɐʦ᠃
 
ăĠ
 
ēŎĖ
 
ȒŶɮő ʫĽ˄
 
ǵĄʌĬȽ
 
īǶĄɆĄő Į
 
ʲĽĞʓ Ġ
 
ʖĬ˃ɆĄʗĬɆĄĠ
 
Ȃʌĕʳŀ
 
ƍ˃ľő᠃
 
ēʯĞɎ
 
ēȁ
 
ǵĦʹĄ˄
 
ŵ˄
 
ʖĬ˃ɆĄȿʗĄő ʫĬ˄᠃
 
ʧĵ˃ŶʓļɐĠ
 
ʋĕʬĕȡĠ
 
ŋĞɐő
 
ŽʒŲĠ᠃
 
ʡĕ˃Ė
 
ȒŶɮő
 
ĝŎĮ
 
ʧĦʒĦɆĄő
 
ʲĞʓ
 
ŽʒĬȿʗĄő ʫĬ˄᠃
 
Ź˃ĄʌĄő Į
 
īǶĄɆĄő Į
 
ʲĽĞʓ ʫľ˄ʋĕ˃ɐő
 
ŽʒĬȿʗĄő
 
ē˃ʬĕʍ ľʦ
 
ĝŎĮ
 
ǵĄʌĬȽ
 
ƍɮʬĕɐ˄ ʡľ˄
 
ʖĦŎĦʗʢĄȿʗĄő  ċ᠃
 
ʡĕ˃Ė
 
ʮĄȽ ʡĬ˄
 
̀ŲʒĞ˻
 
űʒɆĄʗĬő ʫĄȋő
 
īǶĄɆĄő İʲĽĞʓ ʫľ˄
 
ʋĕ˃ɐő
 
ŽʒĬȿʗĄő
 
ǵĄʌĬȽ
 
Ź˃ĄʌĄő
 
ʮĞɆĬʒʳĮ
 
īǶĄɆĄő Į
 
ʲĽĞʓ ʫľ˄
 
ʡĕʌĕʯĕɌʗĕő ʫľ˄᠃
 
Ź˃ĄʌĄő Į
 
ɏĞɌʗĕő
 
ȒŶɮőʋĄʝĠ
 
ʸĕȁ
 
ļʒĕʌʳĠ
 
ŽʒĬȿʗĄő ʫĬ˄᠃
 
ʡĕʬĕɐ˄
 
Ź˃ĄʌĄő
 
Ĵɮʒĕ˄ ľő᠃
 
ăĠ
 
ȒŶɮő
 
Ă
 
ŋĄʗĬő
 
ʮĞŎĮ
 
ēĞʌŀ
 
ʲĄʒĄɆĮƅɐʢĕʓ ę᠃
 
īǶĄɆĄő Į
 
ʲĽĞʓ ʫľ˄
 
ēŎĖ
 
ʋĕʢŀ
 
ʋĕ˃ɐő
 
ŽʒĬȿʗĄő
 
Ȃ˄
 
ƁʹĮ
 
Ȃʌĕő
 
ăʗĄȿŲʗĮ᠃
 
ȒŶɮő
 
Ĵɮʒĕ˄ ľő᠃ʡĦɆĦʒĬȿʗĄő
 
Ɓ˃ǶĄő
 
ŵ˄
 
űȿʝĠ
 
ʋĞŎĮ
 
ƁĠ᠃
 
ŽȿʬĄʘ Ĭő
 
ŋĦʍ
 
ŵ˄
 
ĝŶɐȿʯĠ
 
ʋĞŎĮ
 
ƁĠ᠃
 
Ɓ˃ʗĄř
 
ǵĬˇĄ˃ĄȽ Ĭʦ
 
ŵ˄īʬĬ˃ĞʨʬĬȿʯĠ
 
ʋĞŎĮ
 
ƁĠ᠃
 
ȾĬ˃Ųő
 
ē˃ʬĕŎĞʘ ľő
 
ăʬĞʗʢĞʦ
 
Ȋȿʗĕő ŀ
 
Ƞʯŀ ŵ˄
 
ļĞʒĖ
 
ļ˃ĕʘ ʡľ˄
 
ļŎĕʌʝĞɌʗĕő ŀ
 
ʡĬʒć᠃ʖĕʝĞɊ
 
ļɐĠ
 
ē˃ʢĖ
 
ʜĞʒʢĄɆĄő Į
 
Ȓ˃ĶŘɎ
 
ʖĄʯĬȿʗĄő ʫĬ˄᠃
 
ļ˄ ę
 
ļʒŀ
 
ǵĦʌʗĄʨǶĮ
 
ƁʹĄő Ġ
 
ȊʯĞʹĕɌʗĕő
 
ƁĠ᠃
 
ŋĄʗĬőʋĞŎĮ
 
ʲĄʒĄɆĮ
 
ŽʒŲʗĮ᠃
 
īǶĄɆĄő Į
 
ʲĽĞʓ ʫľ˄
 
ʋĕ˃ɐő
 
ŽʒĬȿʗĄő Į
 
īʯĞ˄
 
ʡĕĞʌŀ
 
ƁĠ
 
᠅
    
᠅
8

蒙古文的特点
•现行蒙古文–5个元音字母–24个辅音字母
9

蒙古文显示的特殊需求
•一个字符最多可以有7个不同的字形
•显示时需要根据上下文确定正确的字形
•竖向排版！
10

藏文文本示例
•“་་
་ཚན་བ་གས་པ”ང་རང་ངས་
ས
ས་ལ་ར་བ་འཕར་འཆར་
ག་ན་ངས་ནས་ལག་བར་་་དང་2015
་ས་མག་་བས་
བས་་ར་ལ་ར་བར་་ན་་ཚད་་
ངས་་1500ན་པ་་
་དང་།ལ་ར་ང་འབབ་ར་ང་ར་180
ན་པ་་།
།ལ་ར་
དཔལ་འར་ལས་གས་་ལས་གས་་ངས་་30ན་པ་
་།ལ་
ར་ལས་གས་་གཏན་འཇགས་་ར་ར་ང་ར་250
ལས་བལ་བ་་
།
།
•“十二五”期间，将全面实施旅游倍增计划，到2015 年末，争取年接待游客达到1500 万人次、旅游收入达到180 亿元；旅游经济就业人数达到
30 万人，旅游行业固定资产突破250 亿元。
11

藏文的文字特点
•现代藏文
–30个辅音字母
–4个元音符号
–音节结构
•梵文的藏文转写
–6个辅音
–40个左右的元音
–用于书写经书
12

藏文的文字特点
•格助词
–属格助词：“的”
–位格助词：主谓宾的标志
•紧缩(黏着)现象屈折变化(动词时、式)
13

藏文显示的特殊需求
•需要将字形做竖直方向的叠加
14

维吾尔文/哈萨克文文本示例
•
•维吾尔文
维吾尔文
•
• ﯗﺷ
 ﯗﺷ ٬ﭖﯩﭼﭔﺋ ﻥﯩﻐﯩﻳ ﺍﺩﯩﺭﯩﺯﺎﺑ ﻯﺯﺎﺷﯩﻣ ﻯﺭﯩﻫﻪﺷ ﻱﯗﺧﭔﺩ ﻥﯛﻛﯕﭔﺷ ﻭﮔ ٬ﻪﺗﭼﻪﻛ ﻰﻧﯛﻛ
 ٬ﭖﯩﭼﭔﺋ ﻥﯩﻐﯩﻳ ﺍﺩﯩﺭﯩﺯﺎﺑ ﻯﺯﺎﺷﯩﻣ ﻯﺭﯩﻫﻪﺷ ﻱﯗﺧﭔﺩ ﻥﯛﻛﯕﭔﺷ ﻭﮔ ٬ﻪﺗﭼﻪﻛ ﻰﻧﯛﻛ
 ٬ﻯﺩﯩﻠﯕﺎﺋ ﻰﻧﯩﺗﻼﻛﻭﺩ ﺕﻪﻣﺯﯩﺧ ﯓﯩﻧﺗﻪﻣﯛﻛﯙﻫ ﻙﯩﻠﯩﻛﻟﯙﺋ ٬ﻡﻭﻛﺗﺭﺎﭘ ﻙﯩﻠﯩﻛﻟﯙﺋ ﻥﯩﻠﯩﺟ
 ٬ﻯﺩﯩﻠﯕﺎﺋ ﻰﻧﯩﺗﻼﻛﻭﺩ ﺕﻪﻣﺯﯩﺧ ﯓﯩﻧﺗﻪﻣﯛﻛﯙﻫ ﻙﯩﻠﯩﻛﻟﯙﺋ ٬ﻡﻭﻛﺗﺭﺎﭘ ﻙﯩﻠﯩﻛﻟﯙﺋ ﻥﯩﻠﯩﺟ
 ﻰﻧﯩﻘﯩﻠﻧﺎﻐﻟﯗﺭﯗﻗ ﯓﯩﻧﯩﺳﯩﭘﭘﯗﺭﯗﮔ ﺵﯛﺭﯛﺷﻛﻪﺗ ﻪﻗەﯞ ﻰﺳﯩﻣﯩﻛﻫﻪﻣ ﻯﺭﯩﻠﺷﯩﺋ ﺕﻪﻟﯙﺩ
 ﻰﻧﯩﻘﯩﻠﻧﺎﻐﻟﯗﺭﯗﻗ ﯓﯩﻧﯩﺳﯩﭘﭘﯗﺭﯗﮔ ﺵﯛﺭﯛﺷﻛﻪﺗ ﻪﻗەﯞ ﻰﺳﯩﻣﯩﻛﻫﻪﻣ ﻯﺭﯩﻠﺷﯩﺋ ﺕﻪﻟﯙﺩ
 ﻰﻛﻧﯩﻳﭔﻛ ٬ﻯﺩﯩﻟﺭﺎﻛﺎﺟ
 ﻰﻛﻧﯩﻳﭔﻛ ٬ﻯﺩﯩﻟﺭﺎﻛﺎﺟﻯﺩﺭﯗﺗﺷﻼﻧﯗﺭﻭﺋ ﭖﯩﻠﯩﻗ ﻪﻣﯩﻛﺎﻫﯗﻣ ﻰﻧﺭﻪﻠﺗﻪﻣﺯﯩﺧ ﻕﯗﻠﭼﯗﻘﺳﺎﺑ
ﻯﺩﺭﯗﺗﺷﻼﻧﯗﺭﻭﺋ ﭖﯩﻠﯩﻗ ﻪﻣﯩﻛﺎﻫﯗﻣ ﻰﻧﺭﻪﻠﺗﻪﻣﺯﯩﺧ ﻕﯗﻠﭼﯗﻘﺳﺎﺑ.
.
15哈萨克文
 »ﯓﯩﻧﯩﺗﺭﺎﺷ ﻰﺳﺭﺎﻗ ﻪﮔﯞﺳﻪﺗﻛﯩﺭﯩﺷ ﯗ ﻡ ﺏ « ﯞﺍﺭﺎﻗ ﻥﯩﻟﺍﯞﺣﺍ ﯞﻠﯩﺭﺎﻘﺗﺍ
 ﻰﺳﻪﻣﺭﯩﻳﯗ ﺭەﺩﻠﯩﻛﺍﯞ ﻭﮕﯕﯗﺟ ﻥﺎﻘﺳﺎﻧﯩﺗﺎﻗ ﻪﻧﯩﺳﯩﻠﯩﺟﺎﻣ ﯓﯩﺩﺭﻼﯩﻋﺍﺩﻧﯩﺳﺎﭘﭘﯞﺭﮔ
 ﯓﯩﺩﺭﯩﻣﺎﻣ
30 -ﻯﺩﺎﺗﺗﺎﭘﺳﯩ ﻰﻧﺎﻧﯩﻣ ﻪﮕﯩﺷﻠﯩﺗ ﻰﻧﯗﻛ :ﯗ ﻡ ﺏ- ﻰﻋﺍﺩﺎﻧەﯙ ﯓﯩﻧ
 ﯓﯩﻧﻭﮕﯕﯗﺟ ﺭﻼﯩﻋﺍﺩﻧﯩﺳﺎﭘﭘﯞﺭﮔ ﯞﺍﺭﺎﻗ ﻪﺗﺳﯩﻠﯩﺟﺎﻣ ﻥﺎﻘﺗﺎﺟ ﭖﯩﻠﯩﺷﺍ ﺍﺩﻧﯩﺳﺎﻣﺭﺎﻘﺳﺎﺑ
 ﯓﯩﺗﺗﺭﺎﺷ ﻥﺎﻌﻟﺎﺗﺍ
3 -٬
4- ﯞﺭﯩﯞﺳ ﻪﺑەﺭﻪﺟ ﻯﺩﯞﺭﻪﺳﻛﻪﺗ ﻥﯩﻳﺍﺩﻋﺎﺟ ﯞﺭﺎﻘﺗﺍ ﻥﯩﺭﻻﯞﺍﺭﺎﺗ
ﻯﺩﻪﺗﻛﯗﺟ ﻪﻧﯩﺭەﺩﻟە ﺎﻣﺎﺣﺎﺑ ﻥﻪﻣ ﻡﺎﻧﺗﻪﻳﯙ ﻰﻠﯩﻗﺭﺍ  .

维吾尔文的特点
•现代维吾尔文–24个辅音–8个元音
•位置变形–21个字母有独立、词首、词中、词尾4种形式–11个字母只有词尾和独立两种形式
•国际标准–44个名义字符形式–162个变形显现形式的字形
•丰富的形态变化
16
(前缀){0,1} + (词根){1,2} + (@构词后缀){0,2} + (@构形后
缀){0,n}

维吾尔文/阿拉伯文编码区块
17

维吾尔文显示的特殊需求
•维吾尔文–21个字母有独立、词首、词中、词尾4种形式–11个字母只有词尾和独立两种形式
18

对研讨问题1的回答
•与汉字相比，将蒙古文、藏文、维吾尔文显示到屏幕上需要做哪些特殊处理？
–按词首、词中、词尾、独立等变形
–字形的垂直方向叠加
•从文本显示的角度来讲，你觉得上述哪种文字处理起来比较复杂？
–藏文？
–蒙古文？
19

对研讨问题2的回答
•传统蒙古文在显示的时候，为什么需要进行变形显现？
–拼音文字：5个元音字母、24个辅音字母
–一个字符最多可以有7个不同的字形
–显示时需要根据上下文确定正确的字形
•影响变形显现的因素？
–字符在词里的位置；
–自由变体选择符FVSn；
–元音间隔符MVS；
–音节与词性引起的变形；
–NNBSP、ZWJ、ZWNJ等控制字符；
–…
20

对研讨问题3的回答
•使用OpenType和Graphite开发传统蒙古文字体时，需要完成的工作有什么区别？
–OpenType字体•OpenType传统蒙文变形引擎开发：判断何时变形、指定变形规则•字库开发：在GSUB和GPOS表中描述变形规则
–Graphite字体•所有工作都在字库中完成：何时变形、如何变形…•使用GDL编写变形规则，规则需具备与OpenType引擎类似的字形上下文判断功能
•你认为哪种技术更为适用？
–OpenType•已有可用引擎的情况下，字库开发工作量小，变形规则编写相对简单•与引擎结合过于紧密、字形正确显示严重依赖于操作系统版本
–Graphite•不需要专门的蒙文变形显现引擎，字体开发更为灵活•字库开发工作量较大，开发难度相对更高



