提纲
典型漏洞
缺陷/漏洞模式
漏洞建模方法

典型漏洞
SQL注入
脚本注入
跨站点攻击
缓冲区溢出

1、SQL注入
SQL 注入的成因主要是因为向数据库提供的SQL 查询
语句是用字符串拼装的方式生成的
最经常遭受SQL注入的页面通常是管理员/
用户登陆点。
不论是asp 或是
jsp，如果不正确的编码，都会出现这
个漏洞

1、SQL注入
checkAdminLogin 将收
集到的用户名和密码信息拼装出SQL 字符串，供DAO 下层使用，以从数
据库中的管理员记录表中读取数据
5假设有一个JSP 页面login.jsp，它会把用户名与密码提交到指定的模块
Controller
调用chekAdminLogin(String userName, String passWord) 进行登陆验证如果从表中找到匹配的记录，则表示验证成功。否则返回Null 表示登陆验证失败。

1、SQL注入
public Admin checkAdminLogin(String userName, String password){String strSQL =”SELECT * FROM TD_ADMIN AS A WHERE A.USERNAME=’” + userName + ”’ AND A.PASSWORD=’” + password + ”’”;
如果有人试图在这里进行恶意攻击：在登陆名输入框中输入123 (任意值) 而在密码输入框中输入’OR ’1’=’1那么由于我们的SQL是靠拼出来的，所以最终提交给数据库的将是:
SELECT * FROM TD_ADMIN AS A WHERE A.USERNAME=’123’ AND A.PASSWORD=’’ OR ’1’=’1’
很显然，这句SQL 由于后面被加上了永真条件，登陆是一定成功的。那么不论登陆者是否是管理员，输入‘OR ‘1’=’1 ，他都将能够登陆系统。

对策之一
Java 中对该模式的实现有PreparedStatment或者
NamingQuery一类的技术，实现了参数与逻辑的分离
，可以从根本上杜绝SQL注入。1、SQL注入

2、脚本注入
这里所说的脚本，通常指的是JavaScript脚本，虽然
JavaScript运行于客户端，并且有安全沙箱的保护，但是放
任恶意JavaScript脚本是十分危险的
一个网站，如果对输入未做合理的验证或过滤，在显示输出
的时候又未做合适的格式化，那么便存在这种漏洞
与SQL注入不同，脚本注入没有直接攻击服务端，实际上是
攻击了客户端
窃取信息！

假设有一个新闻站点，每个新闻允许浏览者进行评论浏览者提交的评论将被存储在数据库专门的表中，并显示在新闻的下边
如果开发者除了字符长度外没有做任何输入合法验证，那么这个站点的评论输入，就存在安全漏洞。
假设我们在评论中输入如下内容:
<script language=”javascript”>alert(“这里存在脚本注入漏洞
.”);</script>
那么，这句话将被存储在数据库评论表中。以后，每一个浏览者打开这个新闻页面是，都将会弹出这样一个消息框。2、脚本注入
上面的攻击者没有做过多的破坏。如果输入:
<script language=”javascript”>window.location.href=”www.baidu.com”;</script>
那么打开这个新闻页面，该页面将被从定向到baidu的页面上。如果目标页面一个有恶意代码的页面，那么每个浏览者的机器都可能中毒。

如果输入:
好文
! 顶<iframe src=”
带病毒的页面
”width=”0” height=”0”></iframe>
那么在新闻页面上看不到任何异状但点击该信息的浏览器会悄悄下载病毒
WEB2.0的流行使页面效果更加绚丽，同时也使脚本注入的攻击力提高不少2、脚本注入

对策之一
提供合理的过滤或者转换程序，在输入存放于数据库前，或者
是显示在页面前，对数据进行处理。
尽一切可能，避免用户的输入有执行的可能。2、脚本注入

3、跨站点攻击
跨站攻击和脚本注入非常相似，但必须要诱使受害者点击链
接才能得以执行
与脚本注入的不同
用于脚本注入的恶意脚本提交后，将存储在服务器数据库中，导致
每个访问问题页面的浏览者都将遭到恶意脚本的攻击
而跨站攻击多数情况是将恶意脚本构造于url参数中，通过欺骗的方
式去诱使受害者点击链接，使得恶意脚本执行
虽然Web 站点上存在安全漏洞，但是Web 站点从未受到
直接伤害
漏洞难于查找，特别容易被忽略cross-site scripting，简称XSS 

恶意攻击者（这里使用Evil.org 表示）通过E-mail 或HTTP 将某银行的网
址链接发给用户（银行用bank.com 表示），该链接中附加了恶意的脚本
（
上图步骤1）
用户访问发来的链接，进入银行网站，同时，嵌在链接中的脚本被用户的浏
览器执行（上图步骤2、3）用户在银行网站的所有操作，包括用户的cookie 和session 信息，都被脚
本收集到，并且在用户毫不知情的情况下发送给恶意攻击者（上图步骤
4）
恶意攻击者使用偷来的session 信息，伪装成该用户，进入银行网站
，进行非法活动（上图步骤5）
3、跨站点攻击

XSS典型利用方式—CSRF（Cross Site Request Forgery）
基本原理3、跨站点攻击

4、缓冲区溢出
□栈溢出漏洞
void main(int argc, char *argv[])
{
char name[16];
strcpy(name,argv[1]);
printf(“%s\n”,name);
return 0;
}Main函数调用时栈结构
Name数组（16字节）
EBP（4字节）
返回地址（EIP，4字节）
EBP—栈底内存低端
内存高端ESP—栈顶
◇输入10字节数据？
◇输入16字节数据？
◇输入20字节数据？
◇输入24字节数据？

提纲
典型漏洞
缺陷/漏洞模式
漏洞建模方法

缺陷模式描述
常见缺陷类型
模式检测技术缺陷模式
缺陷/
漏洞模式

模式辨识从事的是选矿的工作
待查代码代码模型模式辨识缺陷知识
缺陷报告
1、缺陷模式描述
缺陷模式

与具体应用“无关”的知识
词法或者语法
共性特性（死锁、空指针、内存泄露、数组越界）
公共库用法（顺序、参数、接口实现，容错，安全）
与具体应用“相关”的知识
类型定义（操作格式，不含其它信息（信息隐藏））
类型约束（调用的顺序、参数值，接口实现）
需求相关（正确）
定理证明符号执行模型检查
模型检查抽象解释
侧重点在技术（算法）方面！1、缺陷模式描述

显式的
与
隐式的独立的
与
嵌入式的私有的
与
共性的1、缺陷模式描述
缺陷知识缺陷模式

能侧重在知识上吗？
Google 翻译的启示！

1、缺陷模式描述
代码必须遵守各类约束
如果违反，就是缺陷
对不同约束的违反，构成了不同的缺陷模式
约束分类
BNF：宪法
共性约束（库接口）：国家法律、条例等
特定软件的约束（类型）：地方法律、条例

使用约束栈
DBMS接口约束
操作系统接口约束中间件接口约束应用软件约束
语言约束（BNF、基本函数）

2、常见缺陷类型
1. 错误代码1.1. 操作1.2. 方法调用1.2.1.单一方法调用1.2.2.同一个类的多方法调用1.2.3.不同类的多方法调用1.3. 类定义1.3.1.单一接口关联1.3.2.单继承关联1.3.3.其它1.4. 线程1.5.引用2. 不安全代码3. 脆弱代码3.1.需求检查3.2.异常相关3.3.线程3.4.其他4.低效率代码4.1.线程4.2.String和StringBuffer4.3.Number 和Wrapper4.4.其它5. 冗余代码5.1.无用代码5.2.不必要代码5.2.1.不必要的Null检查5.2.2.不必要的代码5.3.复制代码5.4.空集问题

a)“/“或者“/=“跟随着0（除数为0）。
b)在比较两个实体时使用了“==“或者”！=“，如字符串、引用
、浮点型以及双精度型。
c)在if
和while等的逻辑表达式中误用了操作符“=”、“&”和“|”
。正确的应该是“==”、“&&”和“||”。1.1 操作2、常见缺陷类型

a)调用Calendar.set方法设置月份时使用了超出0到11的参数。
b)调用substring时使用0作为参数。
c)在比较数组和非数组、不相关的类和接口、不同类型以及不同接口
时调用equals。1.2.1 单一方法调用2、常见缺陷类型

a)某些类中必须成对使用的方法（必须有严格的顺序）：例如
I/O对象中的open和close。
b)时序方法的约束。
c)初始化错误。
d)使用负数索引或者超过数组长度的索引值引发了数组溢出。1.2.2 同一个类的多方法调用2、常见缺陷类型

如何在目标代码中查找已知的模式？
先做基本扫描：有相近的代码？
再努力提高准确度
特点：
缺陷定位准确
查找效率较高
可以针对“常见”的缺陷3、模式检测技术

缺陷检测技术对比
模式检测侧重共性约束
状态与共性缺陷模式匹配？
模型检测侧重状态
状态是否满足性质？
抽象解释侧重循环
不动点是什么？
符号执行侧重分支
状态有冲突吗？
定理证明侧重不变量
破坏了不变量？结合!

提纲
典型漏洞
漏洞模式
漏洞建模方法

约束模型（5.1）
依赖图模型
形式化模型（时序逻辑模型）漏洞建模

程序依赖图（ProgramDependenceGraph，PDG）用于
intra-procedural的中间表示形式。
什么是依赖图？
节点--表示语句
边表示--控制流和数据流
虚线边表示数据流依赖
实线边表示控制流依赖依赖图模型

i=1printf(i)while(i<11)sum=0printf(sum)
i=i+1sum=sum+iEntry func()PDG的简单例子
void func(){int sum = 0,i = 1;while (i < 11){sum = sum + i;i = i + 1;}printf("%d\
n",sum);printf("%d\
n",i);}

系统依赖图(System Dependence Graph，SDG）图形表
示软件程序间控制依赖关系和数据依赖关系。
PDG主要针对单个的程序来表示内部的各种依赖关系，
SDG是PDG的发展，它着眼于整个软件系统的内部依赖关
系的表示，并且通常是综合组成软件系统的多个程序的依
赖信息而构建的。SDG

SDG的简单例子
控制依赖为实线实箭头表示
数据依赖为实线虚箭头
参数传递由虚线虚箭头
函数调用的边(Call Arc) 由
虚线实箭头
实线的双箭头代表横切边
虚线的双箭头代表通知边
面向对象的程序分析

依赖图模型实例
Char * buf = （char*）malloc（1024）；…free(buf);…free(buf);
ptr_in_1=bufCall free() 1Call free() 2
ptr_in_2=buf二次释放内存漏洞

形式化模型实例：栈溢出漏洞
函数的局部变量在栈中是一个挨着一个排列的，如果
这些局部变量中有数组之类的缓冲区，并且程序中存
在数组越界的缺陷，那么越界的数据元素就有可能破
坏栈中相邻变量的值，甚至破坏栈帧中所保存的EBP
值、返回地址等重要数据。
37
ip

形式化模型实例：栈溢出漏洞
构造栈溢出表达式为：
表示第i次赋值发生的位置，表明的存储的数
据的增长方向
表示每次循环进行覆盖的字节数
表示循环步长
表示循环次数
表示栈底的位置
38))(()
0(1pspp
piiipiipp
1



sp

□堆溢出漏洞
堆块1堆块2堆块3正常堆结构
堆块1堆块2堆块3FlinkFlink
BlinkBlink释放堆块2的过程：
2->Blink->Flink=2->Flink
2->Flink->Blink=2->Blink
2->Blink->Flink=任意内存地址2->Flink=想修改的值
◇逻辑代码—身份验证代码◇函数返回地址
◇函数指针—劫持进程◇改写同步进程入口地址形式化模型实例：堆溢出漏洞

形式化模型实例：堆溢出漏洞
40))(()0())(()0(11pHppsppppsizeiiii


提纲
技术背景
静态分析方法
数据流分析技术
污点传播技术
模型检测技术
定理证明技术
符号执行技术

源代码漏洞分析又称缺陷分析
软件开发通常会引入大量缺陷
普通软件工程师的缺陷密度一般为50~250个缺陷/KLOC
由于有严格的软件开发质量管理机制和多重测试环节，成
熟的软件公司的缺陷率要低得多
普通软件开发公司的缺陷密度为4～40个缺陷/KLOC
高水平的软件公司的缺陷密度为2～4个缺陷/KLOC
美国NASA的软件缺陷密度可达到0.1个缺陷/KLOC
安全形势的严峻性
假设1%的安全缺陷是可被黑客恶意利用实施攻击的，则一个网银客户端大小（5-10万行，600个缺陷）的软件将可能存在3-6个可被利用的漏洞

源代码漏洞分析
直接对高级语言编写的程序进行分析以发现漏洞，通常使
用静态分析方法。
静态分析：是指在不运行软件的前提下进行的分析过程，
分析对象是源代码、或某种形式的中间代码（如Java程
序的字节码）。
针对源代码的分析，会获得更多的语义信息，便于分析。
使用静态分析方法，可以比较全面地考虑执行路径的信息
，因此能够发现更多的漏洞。
if (!strcmp(arg[1], “option”)
strcpy(
buf, arg[2]);
4

源代码漏洞分析
源代码漏洞分析方法分类
基于中间表示的静态分析——以编译原理为基础
形式化静态分析——以数学推理为基础
主要分析技术
数据流分析(抽象解释)
污点传播
符号执行
模型检测
定理证明

提纲
技术背景
静态分析方法
数据流分析技术
污点传播技术
模型检测技术
定理证明技术
符号执行技术

基于中间表示的静态分析
代码解析可以是词法分析、语法分析、控制流分析等。
程序代码模型包括符号表、抽象语法树、控制流图等。
7程序代码代码解析
历史漏洞分析规则提取程序代码模型
静态分析
漏洞分析规则分析结果处理分析结果

形式化静态分析
形式化的分析方法通常验证程序是否满足程序安全的性
质，这需要通过安全属性的描述过程将一些程序的安全
规定转化为程序的安全模型
8程序代码
安全规定形式化建模
安全属性描述形式化模型
形式化分析
安全模型分析结果结果验证

静态分析的不可判定性
静态分析不能完美地确定程序中的漏洞，从可计算性理论
的角度来看，是因为通过静态分析的方法判断一个程序在
运行时的某种特性是一个不可判定问题，即它可以规约为
停机问题的不可判定性。
静态分析的不可判定性可以通过Rice定理证明。
Rice定理：如果图灵机是否具有某个非平凡的性质，只依赖于它
识别的语言，那么就无法使用图灵机准确地判断一个图灵机是否具有这个非平凡的性质。
9

静态分析评价指标
静态分析的不可判定性实际上意味着任何自动化的静态漏洞分
析系统，针对程序的非平凡属性（例如是否存在运行时错误）
，其检测结果不可能做到既是可靠的又是完备的。
可靠的（Sound）意味着分析结果是正确的。
如果分析结果报告程序存在某种漏洞，则程序实际运行时，一定
会在某种情况下触发该漏洞，也就是无误报（False Positive）。
完备的（Completeness）意味着分析结果中包含了所有可能
存在的漏洞。
如果分析结果没有报告某类漏洞，则程序运行时，肯定不会出现
由这类漏洞引发的某种异常行为，也就是无漏报（False 
Negative）。
10

•追求的目标
–可伸缩性
–正确性
–精确性静态分析评价指标

提纲
技术原理
静态分析方法
数据流分析技术
污点传播技术
模型检测技术
定理证明技术
符号执行技术

数据流分析技术
一种用来获取有关数据沿着程序执行路径流动或取值等相
关信息的分析方法。
典型的编译优化技术。程序编译过程中，编译器利用数据流
分析的结果对程序代码进行优化，如循环优化、冗余语句删
除等，主要目标是使得程序运行效率更高。
由于数据的流向和取值问题对于安全漏洞分析也至关重要，
数据流分析技术可直接应用于检测程序漏洞，如xgcc和
findBugs等分析工具。
可以对程序中可能存在的多种漏洞进行分析和检测，如SQL
注入漏洞、内存多次释放漏洞、缓冲区溢出漏洞等。
是一种基础的漏洞分析支撑技术，能为其它漏洞分析方法提
供重要的分析数据支持。
13

数据流分析分类（1）
根据对程序路径的分析精度通常可分为：
流不敏感的分析：不考虑语句的先后顺序，往往按照程序
语句的物理位置从上往下顺序分析每一语句，忽略程序中存
在的分支。分析结果精确度不高，分析简单、分析速度快。
流敏感的分析：考虑程序语句可能的执行顺序，通常需要
利用程序的控制流图，根据分析的方向可以分为正向分析和
逆向分析。
路径敏感的分析：不只考虑语句的先后顺序，还对程序执
行路径条件加以判断，以确定分析使用的语句序列是否对应
着一条可实际运行的程序执行路径。
free(p); ……; *
p = 1;
14

数据流分析分类（2）
根据分析程序路径的深度（路径的范围）分为过程内分析
和过程间分析。
过程内分析：只针对程序中函数内的代码,如PDG 。
结构化设计中，程序依赖图( PDG) 形象而直观地描述了程
序的结构以及各种依赖关系, 提高了分析和理解程序的效率
和准确性。PDG是程序的一种图形表示，它把控制依赖和
数据依赖包含在单个的结构中
PDG 由一个控制依赖子图(Control dependence sub 
graph, CDS)、一个控制流图(Control Flow Gragh, CFG) 
和一个数据依赖子图(Data dependence sub graph, DDS) 
组成。
CDS 包含了程序中的控制依赖；CFG 描述了一个程序中的控制流；DDS 是一个程序中语句之间所有数据依赖的集合。
15

数据流分析分类（2）
0:  void example(.) {1:      int x,y;2:      x=20; y=0;3:      while（x>0){4:               if
（x>10){5:                      x=x-1;6:                      y=y+1;7:                }else{8:                      x=x-1;9:                      y=y-1;10:               }11:        }12:        ASSERT(y=0) 13:  }过程内分析实例(PDG中的CFG)

数据流分析分类（2）
根据分析程序路径的深度（路径的范围）分为过程内分析和过
程间分析：
过程内分析：只针对程序中函数内的代码，如PDG。
过程间分析：需要考虑函数之间的数据流，即需要跟踪分析目标
数据在函数之间的传递过程，如SDG。可分为上下文不敏感的分
析和上下文敏感的分析。
上下文不敏感的分析将每个调用或者返回看作一个“goto”操作，忽略了调用位置和函数参数取值等函数调用的相关信息。
上下文敏感的分析对函数调用的处理包括对不同调用位置调用的同一函数加以区分的过程，通常认为不同位置调用的同一函数可能是不一样的。
过程间分析需要消耗更多时间，全局范围内的过程间分析在很
多情况下是不可行的。在实际的漏洞检测中，可根据分析目标
的大小和分析时间的要求选择采用过程内或过程间的分析。17

提纲
技术原理
静态分析方法
数据流分析技术
污点传播技术
模型检测技术
定理证明技术
符号执行技术

污点传播
一种跟踪并分析污点信息在程序中流动的技术。
将所感兴趣的数据标记为污点数据，通过跟踪和污点数据相
关的信息的流向，检测这些信息是否会影响某些关键的程序
操作。
通常将不可信的数据作为污点数据，这些数据通常来自程序
外，如用户输入数据或程序通过网络接收的数据。
19

污点传播
实际程序分析中，将程序分析所关注的数据标记为污点，其数据
本身并不一定是不可信的。
在检测隐私泄露行为时，通常将用户的隐私数据标记为污点并分析其信息流向，以检测与其相关的信息是否流到程序外。
通过对污点信息的跟踪，程序分析系统可以检测多种类型的程序
漏洞，这些漏洞主要包括SQL注入漏洞、跨站脚本（XSS）、命
令注入漏洞、隐私泄露等。
分析系统可以对程序输入数据的不同位置进行不同的污点标记，
通过应用污点分析技术，分析输入数据中哪些位置影响程序中的
关键操作，分析结果可以对Fuzzing方法构造程序测试用例起到一
定的指导作用。
20

污点传播
污点信息不仅可以通过数据依赖传播，还可以通过控
制依赖传播。（污点分析难点之一）
简单实例
if (x> 0)
y = 1;
else
y = 0;
21

提纲
技术原理
静态分析方法
数据流分析技术
污点传播技术
模型检测技术
定理证明技术
符号执行技术

模型检测
软件模型检测对程序安全属性
进行分析，以此来检测出它们
在执行过程中存在安全漏洞。
1.提取出系统需要验证的属性
规范；
2.对待检测程序系统及其属性
进行抽象、建模；
3.根据相应的系统模型和规范
进行验证。
23

模型检测
主要思想：首先将给定的系统和系统属性进行建模，使用
形式化语言分别用有穷状态模型描述出来，通过遍历状态
空间自动地验证有限状态系统模型M是否满足系统属性s
的问题，即M|=s?。
对于有穷状态系统，这个问题是可判定的，即用计算
机程序可以在有限时间内自动确定。
待检验的系统模型一般使用转换系统(Kripke结构)或
者自动机来描述，而系统的规范、属性则使用时序逻
辑表达式或者自动机来表示。

模型检测
模型检测主要关注程序执行过程中的“时序正确性”
，据此精确地指定待检验的程序安全性质。对于时序
逻辑，模型检查算法主要分为两类：
显式模型检测：主要包括线性时序逻辑的模型检验算
法，主要思想是构建相应规约的语言模型（比如自动
机），而后通过搜索反例路径的方式进行检查。
符号化模型检测：该类算法通过形式化方法对模型和
设定的规约进行抽象转换，以布尔公式或其它形式化
表示形式描述程序执行状态空间，在此基础上遍历状
态空间搜索程序中存在的缺陷。
25

基于反例的抽象求精CEGAR算法
CEGAR是Clarke于2000年提出的，工具有SLAM、BLAST、
MAGIC等。
算法输入：原始模型M，待检验安全属性p；
算法输出：安全属性p在原始模型M中成立，返回TRUE；
安全属性p在原始模型M中不成立，返回FALSE。
1.通过原始模型M和待检验的性质p，产生初始的抽象模型M’；
2.检验p在M’中是否成立，即M’
⟹p是否成立。如果成立，则有M⟹p，证明p在M中可满足
，返回TRUE；否则，转到3；
3.分析M’⟹p不成立的原因，并从M’中找出p的一个反例Ci；
4.在
原始模型M中验证Ci的真实性。如果Ci是真反例，即M⟹p不成立，则证明p在M
中不可满足，返回FALSE；否则，转到5；
5.对M’求精，转到2。
26

提纲
技术原理
静态分析方法
数据流分析技术
污点传播技术
模型检测技术
定理证明技术
符号执行技术

定理证明
主要思想
首先分析需要进行安全性证明的程序，以数学方法给出形
式定义
然后以定理公式的形式描述程序的安全属性，并根据确定
的模式算法转换为可求解的规范表示
最后通过定理证明器根据设定的定义和已经验证正确的定
理对每一个子句为真的进行验证证明
28

定理证明
主要步骤
调研待证明软件系统，确定相应安全需求；
程序定义归纳。根据程序安全分析需求，利用构造算法（
如归纳构造演算）定义程序系统中不同对象，包括类型（如
列表、树等）、表达式、以及状态迁移轨迹等；
将程序安全属性形式化。以形式化方法描述程序安全属性
，不仅包括程序对象的安全属性，而且包括逻辑证明部分；
生成程序属性规范。根据一定的规则，把程序安全属性转
换为定理命题的表达形式，即转换为定理证明器可以识别的
规范逻辑公式子句构成的定理命题；
进行程序正确性验证。根据程序证明策略和相应的算法模
式，使用公理和规则对定理命题进行正确性推理证明。
29

提纲
技术原理
静态分析方法
数据流分析技术
污点传播技术
模型检测技术
定理证明技术
符号执行技术

符号执行
下一节专题介绍
31

小结
介绍了几种针对源代码的程序静态缺陷分析方法
原理，使大家对源代码漏洞分析有一个感性认识
。
使学生理解：即使开源系统的漏洞分析也是非常
困难的，有很多未解决的难题。


提纲
符号执行起源
符号执行基本原理
符号执行工具方法
基于符号执行的缺陷分析示例
2

int x, y;
1: if (x > y) {
2:   x = x + y;
3:   y = x -y;
4:   x = x -y;
5:   if (x > y)    foo1();
6:   else            foo2();
}观察下面程序：
有什么问题？

程序缺陷检测的三部曲
第一部：程序缺陷是什么样子？
程序缺陷建模（缺陷模式）：缓冲区溢出、格式化符号
串、SQL注入、XSS…… （Case by Case）
第二部：在程序的什么地方有缺陷？
遍历程序的所有执行状态空间，并进行缺陷模式匹配。
如何遍历程序的执行状态空间？--符号执行技术。
第三部：如何触发程序缺陷？
分析程序缺陷和程序输入之间的关系。到达关系（符
号执行技术）、输入触发漏洞的条件（污点分析技术）

符号执行
符号执行首先由J. C. King在1976年提出，在软件测试和
程序验证中发挥着重要作用。
使用符号值代替数字值执行程序的技术
将程序中变量的值表示为符号值和常量组成的计算表达式
程序计算的输出被表示为输入符号值的函数
可以直接应用于程序漏洞的检测，也可用于辅助构造
程序测试用例，还可用于程序静态分析中的路径可行
性分析、符号调试等。
5

优点
分析是路径敏感的
因为没有对路径、状态做近似，结果精确
适合做状态检查、时序检查
对并发类型的错误十分有效
缺点
对所有可能的状态进行穷举搜索，开销大
对系统的行为进行近似，可能导致这类结果不精确
对于数据密集的系统分析困难
在边界处对路径、时序属性近似困难，故复合困难符号执行之----路径敏感分析（模型检测）

优点
由于对路径、状态进行抽象，扩展性好
可以对许多有价值的属性构造格
易于组合
提供了坚实的数学基础
缺点
适合的属性需要是简单的、“状态”“值”型的
对时序性质支持弱
属性格的定义不容易
有时近似过强符号执行之----抽象解释（数据流分析）

优点
支持灵活的属性
易于扩展
缺点
开发人员需要提供额外的信息
自动化程度不高
路径不敏感，对并发系统不适合符号执行之----演绎方法（定理证明）
符号执行之----演绎方法（定理证明）

符号执行可以被看作是路径敏感分析、演绎方法及抽
象解释的组合
对路径条件进行近似使得抽象解释的属性区间值收缩
，因此更加灵活
约束近似了许多状态，降低了分析量，经常被应用于
测试输入的生成
传统上，符号执行对有限个整数变量进行符号化，后
来扩展到了处理复杂的输入数据结构和并发
如扩展JPF 工具以进行符号执行Java 程序符号执行之----组合优化

记录执行的状态，包括：
程序变量的符号值
路径条件（PC: Path Condition）
程序标记（后面执行什么）
路径条件非常重要
积累了路径的约束条件
符号执行树
刻画程序符号执行过程中的执行路径符号执行

最初，x 与y 分别具有符号值X、Y
在每个分支点，PC 根据输入的假定确定不同的值
如果PC不成立，该路径不可达
可以大大减少路径组合
int x, y;
1: if (x > y) {
2:   x = x + y;
3:   y = x -y;
4:   x = x -y;
5:   if (x > y)    foo1();
6:   else            foo2();
}x: X, y: Y  (x>y?)  
x: X, y: Y (X>Y)    x: X, y: Y (X<Y)    
x: X+Y, y: Y (X>Y)    
x: X+Y, y: X (X>Y)    
x: Y, y: X (X>Y)    
x: Y, y: X   (X>Y)& (Y>X) x: Y, y: X   (X>Y)& (Y<=X) 
例子：

提纲
符号执行起源
符号执行基本原理
符号执行工具方法
基于符号执行的缺陷分析示例

符号执行基本原理（1）
程序输入变量值的时候，使用符号代替，并用符号模
拟执行程序的过程，以获取程序执行的所有路径（执行树
）及执行条件。
1 int min(int a, int b)
2 { int temp=0;
3 if(a>b) 
4 {temp=b;}
5 else
6  {temp=a;}
7 return temp;
8}符号A代替参数a，B代替参数b
变量temp=0
A>B，则4、7；A<=B，则5、6、7
变量temp=B
变量temp=A
返回A或B

符号执行基本原理（2）
变量a=A变量
b=B
变量temp=0;if(A>B)
temp=Btemp=A
return temp=Breturn temp=AA>B==trueA>B==false①
②③
④⑦
⑤⑥⑦
T
F
PC1：A>BPC2：A<=B

符号执行与状态空间遍历
第一步：符号输入
即将所有输入使用符号代替
第二步：符号执行
得到所有执行路径以及对应PC。
路径1：①②③④⑦，路径条件pc1=A>B；
路径2：①②③⑤⑥⑦，路径条件pc2=A<=B。
第三步：路径遍历，约束求解
遍历所有的路径，并求解路径条件，以获得实际可能执行
路径的输入值

符号执行中的主要问题（1）
状态空间爆炸问题
1 int accum(int n)   //求累计和函数2 { int result=0;3 int counter=1;4 while(counter<=n){5   result+=counter;6   counter++;7  }8  return result;9 }
①②③④⑤⑥④
⑧⑧TTFF

符号执行中的主要问题（2）
约束求解问题
数组引用问题
如果在程序中包含一个数组A，A[I]的引用值完全取决于I的取值，如果I是符号表达式，则在符号执行过程中无法确定A[I]的具体值
第三方程序问题
如果在程序中调用了第三方程序，如何对其进行符号执行？约束求解问题是NP完全问题
线性求解、非线性求解
字符串约束求解

提纲
符号执行起源
符号执行基本原理
符号执行工具方法
基于符号执行的缺陷分析示例
18

静态符号执行工具-PREfix/Prefast
Intrinsa公司,1997年开发的缺陷检查工具PREfix/ Prefast
1999年，该公司以5890万美元的价格被微软收购
Prefast工具被集成到Visual Studio开发工具中

1 #include <stdio.h>
2 #include <stdlib.h>
3 #include<string.h>
4 char *f(int size)
5 {
6 char *result;
7 if(size>0)
8 result=(char *)malloc(size);
9 if(size==1)
10 return NULL;
11 return result;
12 }
检查结果为：
1>d:\test\test2\test2\
main.cpp(12) : warning C6001: Using 
uninitialized memory 'result': Lines: 6, 7, 9, 12。静态符号执行工具-PREfix/Prefast

混合符号执行工具-DART/CUTE（1）
A.随机输入变量，执行程序；
B.将输入变量的地址作为符号变量，执行过程实现符
号计算；
C.记录路径执行过程中约束条件；
D.如果所有路径执行完成，则返回，否则将约束条件
中的最后一个未取反的条件取反后，对路径约束条
件进行求解，得到另一个具体输入变量的值，然后
继续执行B）。

混合符号执行工具-DART/CUTE（2）
0 intf(intx, inty){1 intz ;2 z=y;3 if(x==z)4   if(y==x+10)5    abort();    //表示程序的一个缺陷6 return 0;7 }
随机输入变量值x=123456，y=654321，Mx,My（符号值）(2) Mz=My,z=654321(3)x==z不成立，得到约束条件:<Mx==My>
(6) halt,程序停止约束条件的最后一个进行取反，并进行约束求解，得x=0,y=0，继续符号执行。

混合符号执行工具-DART/CUTE（3）
0 intf(intx, inty){1 intz ;2 z=y;3 if(x==z)4   if(y==x+10)5    abort();    //表示程序的一个缺陷6 return 0;7 }
输入变量值x=0，y=0，Mx,My（符号值）(2) Mz=My,z=0(3)x==z成立，得到约束条件:<Mx==My>(4）y==x+10不成立，得到约束条件：<Mx==My>,<My==Mx+10>
(6) halt,程序停止约束条件的最后一个进行取反，并进行约束求解，无解，所有路径执行完毕。

混合符号执行工具-EXE/KLEE（1）
标记符号输入，并进行符号运算；
当碰到符号表达式时（简单赋值语句、二元运算和条
件语句），由不同的算法实现符号运算，并得到路径
约束条件
EXE/KLEE会为条件语句的TRUE或FALSE插入一个
Fork函数，以生成两条不同的执行路径来。

混合符号执行工具-EXE/KLEE（2）

1
3
5
2a[0]
a[1]
a[2]
a[3]混合符号执行工具-EXE/KLEE

提纲
符号执行起源
符号执行基本原理
符号执行工具方法
基于符号执行的缺陷分析示例
27

2、典型工具：PREfix
1）基本功能
2）关键算法思路
3）主要步骤
缺陷分析示例：PREfix/PREfast

模拟执行单个函数
模拟过程顺序地跟踪不同的执行路径，模拟每个操作符的
动作。在路径执行过程中，通过跟踪内存的状态，应用各
种一致性规则，查找不一致性。
在对条件选择后，通过检查内存的当前状态，分析器可以
限制可达的路径。由于对路径、值的跟踪都很仔细，可以
获得精确的信息。
函数的行为被描述为：条件、一致性规则及表达式值的集
合。行为的这种描述被称为函数的一个模型。在路径执行
过程中，不论何时进入一个函数，该模型被使用，以决定
应用哪个操作1）基本功能

模拟执行整个程序
在模拟执行单个函数过程中产生的信息足够自动地产生
该函数的一个模型
在整个程序中应用这些技术，分析起始于调用图的叶节
点，自底向上地向根处理。随着函数被逐层模拟，缺陷
被不断发现，函数模型被高层的后续模拟所使用
这种自底向上的方法使用一个函数的实现来产生函数的
约束，供上层使用。这对于程序不完整时（程序还没有
开发完，或被分析代码需要适合多个不同的程序）尤其
有效1）基本功能

2）关键算法思路
1   #include <stdlib.h>
2   #include <stdio.h>
3
4   char *f(int size)
5   {
6       char *result;
7
8       if (size > 0)
9             result = (char *)malloc(size);
10     if (size = = 1)
11          return NULL;
12     result[0] = 0;
13     return result;
14 }观察右边代码
有什么问题？

1   #include <stdlib.h>2   #include <stdio.h>34   char *f(int size)5   {6       char *result;78       if (size > 0)9             result = (char *)malloc(size);10     if (size = = 1)11          return NULL;12     result[0] = 0;13     return result;14 }example1.c(11) : warning 14 : leaking memoryproblem occurs in function ‘f’The call stack when memory is allocated is:example1.c(9) : fProblem occurs when the following conditions are true:example1.c(8) : when ‘size > 0’ hereexample1.c(10) : when ‘size == 1’ herePath includes 4 statements on the following lines: 8 9 10 11example1.c(9) : used system model ‘malloc’ for function call:‘malloc(size)’ function returns a new memory block  memory allocated错误消息1：
当size = 1 时，直接返回NULL, 被分配的内存未被释放，也未被返回。

1   #include <stdlib.h>2   #include <stdio.h>34   char *f(int size)5   {6       char *result;78       if (size > 0)9             result = (char *)malloc(size);10     if (size = = 1)11          return NULL;12     result[0] = 0;13     return result;14 }
example1.c(12) : warning 10 : dereferencing uninitialized pointer ‘result’problem occurs in function ‘f’example1.c(6) : variable declared hereProblem occurs when the following conditions are true:example1.c(8) : when ‘size <= 0’ herePath includes 3 statements on the following lines: 8 10 12错误消息2：当size <= 0 时，函数试图
解析一个未被初始化的指
针（malloc in line 9 will 
not be executed).

1   #include <stdlib.h>2   #include <stdio.h>34   char *f(int size)5   {6       char *result;78       if (size > 0)9             result = (char *)malloc(size);10     if (size = = 1)11          return NULL;12     result[0] = 0;13     return result;14 }example1.c(12) : warning 11 : dereferencing NULL pointer ‘result’problem occurs in function ‘f’example1.c(9) : value comes from return value of ‘malloc’ hereProblem occurs when the following conditions are true:example1.c(8) : when ‘size > 0’ hereexample1.c(10) : when ‘size != 1’ hereproblem occurs when ‘memory exhausted’Path includes 4 statements on the following lines: 8 9 10 12example1.c(9) : used system model ‘malloc’ for function call:‘malloc(size)’ function returns 0，memory exhausted错误消息3：
当size >0, 但malloc失败，result 返回NULL 指针时，对其赋值出现错
误

while (there are more paths to simulate){ initialize memory statesimulate the path, identifying inconsistencies and updating the memory stateperform end-of
-path analysis using the final memory state,identifying inconsistencies and creating per
-path summary}combine per
-path summaries into a model for the function算法伪代码：

模拟单个函数需要模拟可达的路径。可达路径的集合包含
所有可能的控制流路径集合。这个集合的大小往往小于明
显的控制流路径。因为相同的条件往往控制多个条件模块
。通常可以选择有代表性的路径来模拟。具体路径数可以
由用户进行配置
模拟一条路径涉及遍历函数的抽象语法树，对树上相关的
语句、表达式求值。被模拟函数的内存状态随着语句的执
行被不断更新。
许多缺陷(如未初始化的内存、NULL或无效的指针解析) 可
以通过在路径模拟过程中对内存的状态应用一致性规则发现
。其他(如内存泄漏，将指针返回给一个释放的内存) 在到
达路径终点时可以被发现
当路径被模拟时，函数的最终内存状态被综合处理
(summarized)。当所有的路径被模拟后，per
-path 
summaries 被组成一个函数的模型

3）主要步骤
路径跟踪
路径跟踪很容易发现一些问题
路径中包括“功能调用、语句、结果”
模拟执行是基于路径进行的，为定位缺陷提供依据
但不一定是唯一的路径
可能是多条路径累积的结果

内存（变量）：值与断言
模拟过程中函数使用的内存需要尽可能准确地跟踪
每块内存都有值：3个基本状态
知道准确的值（常量）
有一个初始化的值，但不知道准确的值
未初始化的值
断言（predicate ）也可能与值关联
断言可能是由1 到3 部分组成
单个：initialized
两个：x>3
三个：a = b + c

内存操作：求值、测试与设置
设置(setting)将一个值赋给内存，改变了内存的状态
简单推理：( a>3& b>4 ) => a+b>7
测试(testing)在一定的上下文中对表达式求值，得到一个布
尔结果。需要进行测试的三种情形：
需要判定表达式，以得到一个布尔结果(例如：条件分支)
语言语义要求（例如：使用前必须初始化）
在模型中选择可能的输出(例子见后面关于“模型”的内容)

条件(condition)、假定(assumption)与选择点
条件可以比路径更清晰地描述缺陷
在路径模拟执行过程中，条件对应于假定
当变量出现在一个表达式中、且值不确定时，可以进行
假定
例子中的“size”: 输入参数，模拟是自底向上进行的
出现两个假定，分别模拟执行，并记忆当前假定
当作出一个假定时，相关内存的状态被更新
这个假定可能提高其它断言的准确性
对于a=b+5, 当假定条件表达式a==2 为真时，a 对应的内存状态更新为2，b 对应的内存状态可以更新为-3。
此时，控制流没有由已知的值完全确定下来，被称为选
择点

路径结尾分析
当一条路径中的所有语句被模拟执行后，可以进行一些附
加分析
发现一些特殊的缺陷。如内存没有释放等
多路径分析
一条长的路径可能因为调用而包含多条子路径
–需要分别分析
–为控制总体数目，可以设置上限
–路径选择是一个问题

模型
模型模拟了函数的行为
模拟器遇到一个函数调用时，它通过函数的模型来模拟被
调用的函数
函数的模型主要是一组输出集合，这些输出代表了函数计
算时对内存状态的可能改变
每个输出由Guards、Constraints、Results构成
约束（Constraint）是前置条件：fopen 的参数必须有效
结果（Result）是后置条件：fopen 执行后返回值有效
防卫（Guards）是测试：某个特定的输出可能依赖某个输
入

(deref
(param p)
(alternate return_0
(guard peq p NULL)
(constraint memory_initialized p)
(result peq return NULL)
)
(alternate return_X
(guard pne p NULL)
(constraint memory_initialized p)
(constraint memory_valid_pointer p)
(constraint memory_initialized *p)
(result peq return *p)
)
)1 int deref(int *p)
2 {
3    if (p= =NULL)
4    return NULL;
5    return *p;
6 }一个模型的例子：

小结
详细剖析了基于符号执行技术的漏洞分析原理与
工具方法，使大家对源代码漏洞分析有一个深入
了解。
使学生理解：目前源码漏洞分析的发展趋势及其
存在的难点。


prefast 工作原理& 设计依据
PREf
ast is a static analysis tool that can detect certain kinds of errors in source code, errors that are not easily found by the typical compiler or by conventional testing.

prefast 工作原理& 设计依据
1.prefast
工具概述
2.prefast
的工作原理
3.prefast
的理论基础
4.prefast
的使用方法
5.prefast
的局限性

prefast概述
This C/C++ Code Analysis tool provides information to developers about possible defects in their C/C++ source code. 
Common coding errors reported by the tool include 
①buffer overruns, 
②un-initialized memory, 
③null pointer dereferences, and 
④memoryand resourceleaks.

prefast概述---特性
1.IDE（integrated development environment）IntegrationIt is fully integrated within the Visual Studio IDE
2.#pragma SupportDevelopers can use the #pragma directive to treat warnings as errors; enable or disable warnings, and suppress warnings for individual lines of code.
3.Annotation SupportAnnotations provide additional information about pre-and post-conditions on function parameters and return types.
4.Run analysis tool as part of check-in policy
5.Team Build Integration
6.Command-line supportIn addition to the full integration within the development environment, developers can also use the analysis tool from the command line, as shown in the following example:C:\>cl /analyze Sample.cpp

prefast概述---静态分析

prefast工作原理
PREfastinterceptsthe build utility's call to the regular cl compiler
, cl.exe. 
The prefastcommand runsa cl intercept compiler, which analyzes the source codeand creates a log file of error and 
warning messages. 
PREfastoperates separatelyon each function in the source 
code. 
It produces a single combinedlistfor all the files checked in a single run and eliminates duplicate errors and warnings generated by header files. 
PREfastthen calls the regular compiler to produce the usual build output. The resulting object files are the same as those produced by your usual build command.

prefast理论基础
PREf
astsimulates execution of allpossible code paths on a 
function-by-function basis, including code paths that are 
rarely executed during run time. 
PREf
astchecks eachpossible code path against a set of 
rules that identify potential errors or bad coding practices, and it logs warnings for code that appears to break the rules. 
1 int min(int a, int b)
2 { int temp=0;
3 if(a>b) 
4 {temp=b;}
5 else
6  {temp=a;}
7 return temp;
8}
①
②③
④⑦
⑤⑥⑦
T
F
路径1：①②③④⑦，路径条件pc1=A>B；路径2：①②③⑤⑥⑦，路径条件pc2=A<=B。

prefast使用方法
visual studio 2013  Code Analysis

prefast使用方法
C/C++ Code Analysis 
warnings   C6001
int f( bool b ){int i= -1;
if ( b ){i = 0;}return i;}1 int f( bool b )2 {3int i;
4if ( b )5{6i = 0;7}8return i;9 }
i is unintialized if b is false
路径条件pc1=b is true
路径条件pc2=b is false

prefast使用方法
C/C++ Code Analysis 
warnings   列表
应用Prefast的关键是要理解其输出的各类警告信息，并作出正确的评估和代码修改。下面网址罗列了code analyze报出的警告的含义以及解释。https://msdn.microsoft.com/en-us/library/a5b9aa09.aspx
C1250   C1251   C1252   C1253C1254   C1255C1256   C1257
C6001C6011   C6014   C6029   C6031   C6053   C6054   C6059
C6063   C6064   C6066   C6067   C6101   C6102   C6103   C6200 …                                             
刚分析过

prefast使用方法
C4703

prefast使用方法
C4703

prefast局限性
Because PREfast analyzes code on a function-by-function basis,it has no information about global state or work performed outside the function being analyzed that might affect a given code path. 
As a result,PREfast issues some warnings that might not represent actual errors in code.

1   #include <stdlib.h>2   #include <stdio.h>34   char *f(int size)5   {6       char *result;78       if (size > 0)9             result = (char *)malloc(size);10     if (size = = 1)11          return NULL;12     result[0] = 0;13     return result;14 }example1.c(11) : warning 14 : leaking memoryproblem occurs in function ‘f’The call stack when memory is allocated is:example1.c(9) : fProblem occurs when the following conditions are true:example1.c(8) : when ‘size > 0’ hereexample1.c(10) : when ‘size == 1’ herePath includes 4 statements on the following lines: 8 9 10 11example1.c(9) : used system model ‘malloc’ for function call:‘malloc(size)’ function returns a new memory block  memory allocated错误消息1：
当size = 1 时，直接返回NULL, 被分配的内存未被释放，也未被返回。

1   #include <stdlib.h>2   #include <stdio.h>34   char *f(int size)5   {6       char *result;78       if (size > 0)9             result = (char *)malloc(size);10     if (size = = 1)11          return NULL;12     result[0] = 0;13     return result;14 }
example1.c(12) : warning 10 : dereferencing uninitialized pointer ‘result’problem occurs in function ‘f’example1.c(6) : variable declared hereProblem occurs when the following conditions are true:example1.c(8) : when ‘size <= 0’ herePath includes 3 statements on the following lines: 8 10 12错误消息2：当size <= 0 时，函数试图
解析一个未被初始化的指
针（malloc in line 9 will 
not be executed).

1   #include <stdlib.h>2   #include <stdio.h>34   char *f(int size)5   {6       char *result;78       if (size > 0)9             result = (char *)malloc(size);10     if (size = = 1)11          return NULL;12     result[0] = 0;13     return result;14 }example1.c(12) : warning 11 : dereferencing NULL pointer ‘result’problem occurs in function ‘f’example1.c(9) : value comes from return value of ‘malloc’ hereProblem occurs when the following conditions are true:example1.c(8) : when ‘size > 0’ hereexample1.c(10) : when ‘size != 1’ hereproblem occurs when ‘memory exhausted’Path includes 4 statements on the following lines: 8 9 10 12example1.c(9) : used system model ‘malloc’ for function call:‘malloc(size)’ function returns 0，memory exhausted错误消息3：
当size >0, 但malloc失败，result 返回NULL 指针时，对其赋值出现错
误

prefast局限性
Error1error C4703: potentially uninitializedlocal pointer variable 'result' used当size = 1 时，直接返回NULL, 被分配的内存未被释放，也未被返回
当size <= 0 时，函数试图解析一个未被初始化的指针
当size >0, 但malloc失败，result 返回NULL 指针时，对其赋值出现错误

讲解KLEE 动态分析工具的安装与使用
KLEE is a symbolic virtual machine built on top of the LLVM compiler infrastructure, and available under the UIUC open source license.

KLEE 动态分析工具的安装与使用
1.Tips for installing KLEE
2.KLEE Usage

2015/10/21Tips for installing KLEE:安装提示
llvm-2.9下make报错
“lseek64”was not declared
解决办法：llvm-2.9/lib/ExecutionEngine/JIT/Intercept.cpp中添加#include <unistd.h>

2015/10/21Tips for installing KLEE
ministat/build$cmake ../
ERROR:missing ZLIB_LIBRARY ZLIB_INCLUDE_DIR
sudo apt
-get install zlib1g-dev

2015/10/21Tips for installing KLEE
安装uclibc时报错
./configure --make-llvm-lib
sudo apt
-get install libncurses-dev

2015/10/21Tips for installing KLEE
./configure \
--with-llvm=/home/yangke/Program/KLEE/llvm-2.9 \
--with-stp=/usr
/local/bin \
--with-uclibc=/home/yangke/Program/KLEE/klee-
uclibc\
--enable-posix-runtime

2015/10/21KLEE Usage
测试
重现

2015/10/21KLEE Usage
Regexp.c

2015/10/21KLEE Usage
Regexp.c

2015/10/21Tips for installing KLEE
缺少tabulate
这是个python的制表包
sudo apt
-get install python-pip
sudo pip install tabulate

2015/10/21Tips for installing KLEE
coreutils-6.11/obj-llvm/src$klee\
--only-output
-states-covering-new \
--optimize \
--libc=uclibc--posix-runtime \
./echo.bc--sym-args024

2015/10/21KLEE Usage
zcov

2015/10/21KLEE Usage
Solve the maze

KLEE Usage
授课时的例子（1）

KLEE Usage
授课时的例子（1）

KLEE Usage
授课时的例子（1）

KLEE Usage
授课时的例子（1）

KLEE Usage
授课时的例子（2）

KLEE Usage
授课时的例子（2）

KLEE Usage
授课时的例子（2）

KLEE Usage
授课时的例子（2）
当size = 1 时，直接返回NULL, 被分配的内存未被释放，也未被返回
当size <= 0 时，函数试图解析一个未被初始化的指针
当size >0, 但malloc失败，result 返回NULL 指针时，对其赋值出现错误
size =2147483647   0x 
7FFFFFFFsize = 0 size =127
