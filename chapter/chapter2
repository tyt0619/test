跨站攻击实例
跨站攻击实例
攻击目标：
使客户在更高的特权运行一段攻击者代码（特权提升
）
攻击过程
攻击者在可信站点上放置内容
客户下载内容，内容攻击一个未打补丁的客户程序
（如：media player
）
攻击者可以客户的用户身份运行
安装一个反向shell后门
下载一个反向提权程序
攻击其它机器

XSS
XSS思考
思考
思考
问题出在哪？
存在有缺陷的程序
•（media player
）未打补丁
对手可以访问到
•通过脚本和内容访问media player
对手有利用的能力
•缓冲区溢出。。。
对手可以按照自己的意愿行事
•网络连接
•下载程序
•提权
•……
能从操作系统角度防止什么？

操作系统
操作系统
希望从操作系统得到
什么保证
？
1.实现进程的隔离2.管理进程的交互
保证在所有交互方式
下达成系统安全目标

系统安全目标
系统安全目标
举例：
用户执行执行授权的操作
safety
进程只能执行必要的操作
最小特权
只能允许信息向更安全的级别流动
MLS

信任模型
信任模型
对于OS
Trust model == TCB
TCB：可信（假设会按正确的方式做事）的基础设施
硬件（键盘，显示器）
操作系统
具有特权的程序和命令
处理敏感信息的程序
配置文件
本地网络
管理员、同一系统的其他用户
目标：as little as possible
TCB越大，需要进行的假设越多（假设不成立的可能
性也越大）

威胁模型
威胁模型
威胁：
攻击者可用来破坏系统安全目标的手段
威胁从哪来？
•外部、内部
通过威胁可以做什么？
•XSS的情况
威胁危害到了什么？
•CIA
TCB必须保护进程免受威胁

威胁模型
威胁模型——
——完整性威胁
完整性威胁
混淆的代理人（Confused Deputy ）
进程被诱使按对手的意志行事，而这种行为是对手自
己无法进行的
如，通过文件、网络、IPC的恶意输入

威胁模型
威胁模型——
——机密性威胁
机密性威胁
特洛伊木马
用户的一些进程泄漏秘密数据
如：下载恶意程序泄漏数据

威胁模型
威胁模型——
——可用性威胁
可用性威胁
拒绝服务攻击

针对
针对XSS
XSS攻击的情况
攻击的情况
组件
Web server, Web client, Media player
Client OS, Root processes, Attacker
信任模型
Client OS
威胁模型
很多安全目标
防止未授权的远程访问
对用户进程进行控制
防止root提权

操作系统和安全
操作系统和安全
理想情况实际情况
完整性对手不能修改进程控制对进程及进程所使用资
源的修改
保密性对手不能从进程窃取
数据控制对进程及进程所使用资
源的访问
可用性对手不能防止进程使
用硬件资源控制对硬件的共享使用
提供的安全机制能够保证
即使在有攻击者威胁的情况下
可信组件也能够保证系统安全目标的实现

如何进行安全系统设计
如何进行安全系统设计
标识出核心的安全方案
目标、信任模型、威胁模型
将安全方案与系统组件进行映射
什么软件组件必须列在信任模型中
对安全方案进行定制细化
需要综合理解安全模型和系统功能

如何进行安全系统设计
如何进行安全系统设计
定义安全目标
定义信任模型
定义威胁模型
实现参考验证机制
定义正确的安全策略
有效的参考监控机制
保护系统

大纲
大纲
操作系统安全保护需求分析
保护系统设计思想
参考监控器设计实例
参考监控器设计思想

保护系统
保护系统
定义
授权
决定主体是否可以对客体执行所请求的操作
保护状态（S）
是有关主体、客体、操作的授权查询结果
保护状态操作（M）
可以改变保护状态
增加或去除主体对客体实施某操作的权限
保护系统
管理系统的授权策略（安全目标）
定义每个主体可对每个客体进行的操作
表示了
保护状态& 保护状态操作

访问矩阵
访问矩阵
访问矩阵是表示策略的一种方式
最常用的一种
列标识客体，行标识主体
在相应位置找到Si是否有访问Oj
的权限
访问矩阵代表O(|S|*|O|)规则
每种权限对应一个矩阵

保护系统
保护系统
访问矩阵保护系统
保护状态
矩阵当前的状态
保护状态的修改
通过保护状态操作进行
•如：创建客体
•如：属主增加映射到客体的主体、操作
在Lampson的论文中提出
可以将执行保护状态操作的能力指派给他人
2015/9/8

保护系统
保护系统
对XSS存在的问题
保护系统方案不全面
进程可以改变自身权限
进程不可信，却可能影响安全目标
进程、文件等可被创建、修改
如何按照安全目标管理这些行为？
怎样进行必要的控制
安全目标的定义和实施
声明：如果可以定义并实施保证安全目标的策略，则
可以防止相应的攻击
如何知道策略表达了有效的目标？
怎样知道实现机制是否按预期方式实施了策略？2015/9/8

保护系统
保护系统
强制保护系统
一个只能由可信的管理机制修改的保护系统，包括下
面三方面：
强制保护状态
•保护状态通过与客体、主体相关的标签进行定义
•标签集合由可信管理机制定义
标记状态
•可为客体主体指定强制保护状态中的标签
转换状态
•定义客体、主体标签被重置的合法形式
强制保护系统是不可变的
2015/9/8

强制保护系统
强制保护系统
2015/9/8

保护系统
保护系统
强制保护状态
不变的
主体标签表
客体标签表
操作表
OS的强制保护系统
隔离root
进程与media player
无网络访问
基于标签限制media player
的操作（可信不可信的输入）
不能发起网络连接
不能下载程序
不能生成root
进程
2015/9/8

保护系统
保护系统
标记状态
不变的规则映射
主体的标签
客体的标签
OS的标记状态
浏览器、Media Player
有自己的主体标签
网络连接带有标签
Root及TCB程序文件有标签，基于信任程度确定
定义确定所有客体标签的需求
2015/9/8

保护状态
保护状态
转换状态
不变的规则映射
改变主体标签的条件
改变客体标签的条件
OS的转换状态
在接受不可信输入时改变进程标签
在接受秘密输入时改变文件标签
程序的转换状态
一些服务器可被信任改变其标签
2015/9/8

保护系统
保护系统
管理强制保护系统
挑战
确定如何在一个包含多个参与方的复杂系统中设置、管理强制保护系统
参与方
程序员对安全部署程序有多少了解
OS发行者对在系统环境中运行程序有多少了解
管理员对程序和OS有多少了解？
用户？
2015/9/8

大纲
大纲
操作系统安全保护需求分析
保护系统设计思想
参考监控器设计实例
参考监控器设计思想

参考监控器
参考监控器
目的：保证安全目标的实现
强制保护状态定义目标
参考监控器保证实现
每一个被依赖实施安全目标的组件都必须是一个参考
监控器2015/9/8

参考监控器
参考监控器
组成
参考监控器接口
（如：LSM）
通过构造待评估的查询来对安全敏感操作进行仲裁
授权模块
（如：SELinux）
确定相关的保护状态项来确定授权查询结果
策略存储
（如：二进制策略）
存储/获取保护状态项

参考监控器保证
参考监控器保证
Complete Mediation
参考监控器验证机制一定要能被调用
Tamperproof
参考验证机制必须是防篡改的
Verifiable
参考验证机制必须要进行分析、测试，其完备性必须
要能够保证
2015/9/8

Complete 
Complete Mediation
Mediation
每个安全敏感操作都要被仲裁
什么是安全敏感操作
如：允许带有一个标签的主体访问不同标签的客体的操作
如何检验Complete Mediation
必须标识每个这样的操作
如：可以检查仲裁的覆盖率
Mediation：接口是否进行了仲裁？
Mediation：是针对所有资源吗？
Mediation：可验证吗？

Tamperproof
Tamperproof
防止被非可信实体修改
包括参考监控器的接口、机制、策略
会影响参考监控器的代码及策略
如何检测Tamperproof
操作的传递闭包
挑战：总是会出现一些不可信操作
Tamperproof
：是否对参考监控器进行了保护
Tamperproof
：是否对TCB进行了保护

Verification
Verification
测试和分析参考验证机制
代码执行正确吗？
策略定义正确吗？
确定代码和策略的正确性
什么是正确的代码？
什么是正确的策略？
Verification：TCB代码基正确吗？
Verification：保护系统是否实现了系统安全目标？

参考监控器评估
参考监控器评估
2015/9/8Mediation:接口进行仲裁了吗？
Mediation:针对所有资源进行了吗？
Mediation:可验证吗？
Tamperproof:参考监控器被保护了吗？
Tamperproof: TCB被保护了吗？
Verifiable: TCB基础代码正确？
Verifiable: 保护系统实现系统安全目标了吗？

多重参考监控器
多重参考监控器
参考监控器概念产生时
针对一个集中的参考验证机制定义
多个这样的机制一起作用会怎样？

大纲
大纲
操作系统安全保护需求分析
保护系统设计思想
参考监控器设计实例
参考监控器设计思想

Multics
Multics
介绍
多处理器系统，产生了很多OS的概念
1965年开始，70年代中期还在开发
2000前一直在使用
初始的参与者：MIT，Bell Labs，GE/Honeywell
安全目标（随系统开发改变，初始目标如下）
保密性
防止泄露——即使运行不可信程序时
完整性
防止非授权的修改——信任层次
全面控制
（在最底层实施）

Multics
Multics安全
安全
保密性
多级安全（MLS）
完整性
保护环
全面控制
对segment access，ring crossing进行仲裁
该系统被认为是一个高起点的安全系统设计

Mutics
Mutics的参考监控器
的参考监控器
Mediation
针对segment上的安全敏感操作
所有对象通过命名的segment层级访问
Tamperproofing
参考监控器是kernel环的一部分
对kernel外的软件的依赖最小化
可验证
大量代码（54K 源代码行）
MLS的机密性（是MPS），rings的完整性（不是MPS）
未符合参考监控器要求
完整性不是一个MPS
代码量大，无法验证正确性

UNIX & Linux
UNIX & Linux
访问控制
针对文件
所有客体都是文件
网络？
传统的保护系统
有限的访问矩阵
自主保护状态操作

UNIX&Linux
UNIX&Linux参考监控器
参考监控器
Mediation: Does interface mediate correctly?
一些影响安全的操作未检查
Mediation: On all resources?
没有针对网络进行
Mediation: 
Verifably?
不是MPS
Tamperproof
: Is reference monitor protected?
OS没有被保护
内核模块、可信进程、可扩展功能
策略可由非可信进程修改（自主的）

UNIX&Linux
UNIX&Linux参考监控器
参考监控器
Tamperproof
: Is system TCB protected?
没有确定的范围
所有root及setuid进程和它们依赖的程序
管理员可以root运行的所有程序
Verifiable: Is TCB code base correct?
No
Verifiable: Does the protection system enforce the 
system’s security goals?
目标是什么？

总结
总结
强制保护系统
目的是定义不受应用程序影响的安全目标
参考监控器概念
正确实施MPS的参考验证机制的要求
在真正找到一致的方式定义MPS，并验证参考监控器
的必须满足的各项要求前，只能继续使用不安全的系
统。
这也是系统安全研究的挑战

如何进行安全系统设计
如何进行安全系统设计
定义安全目标
定义信任模型
定义威胁模型
实现参考验证机制
定义正确的安全策略
有效的参考监控机制
保护系统

大纲
大纲
什么是访问控制策略和模型
机密性策略及模型
访问监控器设计实例
完整性模型

策略
策略
策略规定了安全的规则
是刻画系统操作的安全过程或配置的声明
可接受的行为的集合
如：机场策略
脱掉鞋
瓶子不能超过3orz
空瓶子行吗？
行李要进行X光扫描
单独放置笔记本，脱掉衣服
穿过金属检测器
目标：
防止将武器、易燃物品、危险物品带上飞机
是否有效？
2015/9/8

计算机安全策略目标
计算机安全策略目标
机密性
不允许未授权主体读
控制已授权主体可以将数据写到哪
完整性
不允许依赖于更低完整性的数据/
代码
可用性
必要的功能一定要能够运行
2015/9/8

访问控制
访问控制/
/
授权
授权
确定特定主体针对客体集合拥有什么权限（操作）
它回答如下问题
‣Do youhave the right to read/
etc/
passwd
‣Does Alicehave the right to view the CSE website?
‣Do studentshave the right to shareproject data?
‣Does Dr. Jaeger have the right to change your grades?
简化的访问控制
主体：做事的活动实体
客体：是被动一方
权限（操作）：是执行的操作
2015/9/8

安全模型
安全模型
安全模型：
用来表达策略的语言
特点
精确、无歧义
简单抽象、易于理解
是安全相关的，只涉及安全性质
是安全策略的清晰表达
其中
一些专门针对机密性：BLP
一些专门针对完整性：Clark-Wilson
一些关注于职责：RBAC
一些专门针对最小特权：SELinuxType Enforcement
系统模型+安全策略=安全模型
2015/9/8

形式化安全模型
形式化安全模型
非形式化安全模型
用自然语言模拟系统的安全功能
形式化安全模型
使用数学模型，精确描述安全性及在系统中的使用情况无二义，可证明
基本要求
完备性：
安全策略包含在模型断言中
所有模型断言必须从安全策略中导出
正确性：
模型的安全性定义，是安全策略导出的安全断言的精确描述
一致性
模型中的各条要求是相互一致、无矛盾的
简明性
只刻画安全相关部分

大纲
大纲
什么是访问控制策略和模型
机密性策略及模型
访问监控器设计实例
完整性模型

BLP
BLP的安全目标
的安全目标
针对机密性保护定义
主要目标是防止安全数据的泄漏
密码也是用来防止信息泄漏的
防止非授权方从一个秘密文件中读取数据
BLP是一种多级安全（MLS）策略
主体、客体都有安全级别
Top Secret > Secret > Confidential >Unclassified
安全目标（机密性）：信息不能流向不安全的级别

多级安全
多级安全
一个多级安全系统对所有客体/主体设置安全标签，
将其按敏感/访问级进行划分
基于这些级别用公式表示访问控制策略
还可以增加其他维度，用“类别”表示水平方向的权
限空间划分（类似于角色）
在美国国防部使用
级别：
UNCLASSIFIED < CONFIDENTIAL < SECRET < TOP SECRET
类别（实际是一个无边界集合）
NUC(lear
), INTEL(igence), CRYPTO(graphy)

针对机密性的
针对机密性的MLS
MLS
机密性需求：不向非授权实体泄漏数据
只允许信息从低密级向高密级主体或对象流动

赋予安全级别
赋予安全级别
所有主体被指派安全级别（clearance level）和类别
（compartment
）
Alice: (SECRET, {CRYTPO, NUC})
Bob: (CONFIDENTIAL, {INTEL})
Charlie: (TOP SECRET, {CRYPTO, NUC, INTEL})
所有课题被指派访问类（access class）
DocA: (CONFIDENTIAL, {INTEL})
DocB: (SECRET, {CRYPTO})
DocC: (UNCLASSIFIED, {NUC})

评估策略
评估策略
满足如下要求访问被许可
subject clearance level >= object sensitivity level 
and
subject categories ⊇object categories (read down)

BLP
BLP的方案
的方案
使用状态转换系统描述计算机系统
定义一个系统，如果其可达状态满足三个属性，则称
系统是安全的
简单安全属性、*特性、自主安全属性
证明一个基本安全定理（BST）
通过系统描述的行为，证明系统是安全的

BLP
BLP安全模型
安全模型
计算机系统被表示为一个状态迁移系统
其中，有一个主体集合，其中一些被认为是可信的
每个状态包含
各个客体
访问矩阵
当前访问信息
状态转换规则描述一个系统如何从一个状态变为另一个状态
每个主体有个最大安全级Lm(s)，及一个当前安全级Lc(s)
每个客体有一个级别。

BLP
BLP模型的元素
模型的元素

BLP
BLP安全模型
安全模型
每个状态必须满足的三条安全性质
简单安全性（不上读）：
若Lm(S) ≥ L(O)，则S可读O
*-属性（不下写）：
若Lc(S) ≥ L(O)，则S可读O
Lc(S) ≤ L(O)，则S可写O
自主安全属性
每个访问都必须是访问矩阵允许的
如果系统的任何可达状态是安全的，则系统是安全的

*
*-
-属性的说明
属性的说明
针对主体而不是用户定义的
用户必须被信任不在线下泄漏秘密信息
技术手段无法限制系统外的用户
主体不被信任
执行的代码可能存在Trojan Horse
*-属性防止了信息的公开泄漏，没有考虑隐蔽信道问
题

BLP
BLP模型的安全性分析
模型的安全性分析
BLP的安全目标
低许可级的主体不应该读密级高的信息
简单安全属性和*-属性在任何给定状态可阻止这类信
息流
跨越状态的情况？
BLP安全还不够
设系统中主体s1,s2,o1,o2f
S(s1)=f
C(s1)=f
O(o1)=high
f
S(s2)=f
C(s2)=f
O(o2) =low
执行序列：
s1访问o1→读→释放操作→ f
C(s1)=low→s1访问o2→写o2→
每个状态都是安全的，但存在非法信息流
解决方案：平稳定律：主体不能改变当前安全级

BLP
BLP的其它问题
的其它问题——
——
隐蔽信道
隐蔽信道
使用一个不是用来传输数据的信道进行通讯
因为信道不是用来通讯的，所以不是访问控制策略的
一部分
隐蔽信道的类型
存储信道
使用有有限容量的设备，如：共享磁盘
时间信道
使用同时只有一方可用的共享设备，如：CPU
实例：
如果存储空间满，代表1，否则代表0
访问控制不能指定谁可以填满磁盘

BLP
BLP模型的问题
模型的问题——
——
系统中的可信主体
系统中的可信主体
军方确实实施着BLP模型
但在系统要运行需要很多可信及不可信实体间的交互
比如大家都需要来自服务器的回应
结果：需要依赖于很多应用程序来管理信息流动
如：Logrotate服务，它按顺序轮询日志
保密性：日志跨越系统所有安全级
必须信任logrotate按照格策略读写数据

BLP
BLP模型的问题
模型的问题——
——
系统中的可信主体
系统中的可信主体
OS信任很多特权程序可以维护系统机密性

其它
其它——
——MLS
MLS的引申
的引申
信息流
观察信息在进程间通过客体的许可流动
信息流的目标
以图表示：G = (V, E)
一个节点集合（每个标签一个点），和节点间的直接边（授权操作）
•边（u，v）表示，u可写v，或v可读u
目标可描述为图的可达限制
G中没有x到y的流
G中必须从x流向z
如果所有可达限制都满足，则系统是安全的

其它
其它——
——MLS
MLS的引申
的引申
信息流
观察信息在进程间通过客体的许可流动
信息流的目标
以图表示：G = (V, E)
一个节点集合（每个标签一个点），和节点间的直接边（授权操作）
•边（u，v）表示，u可写v，或v可读u
目标可描述为图的可达限制
G中没有x到y的流
G中必须从x流向z
如果所有可达限制都满足，则系统是安全的

其它
其它——
——MLS
MLS的引申
的引申
保护保密性的信息流
数据以单方向流动
如：格
标签的偏序集合
每一对元素的LUB（最小上界）和GLB（最大下界）
Denning的格模型
形式化信息流模型Policy = {SC, /, →}
安全策略可形成一个格
{SC, →}是一个偏序集合
SC是有限的
SC有下界
/是最小上界操作符
BLP是这类模型中最简单的模型

其它
其它——
——MLS
MLS的引申
的引申
Denning的公理
SC是有限的
比较保护系统和safety问题
→是SC上的偏序
自反性
传递性
反对称性
SC有一个下界——如：公开数据
/（合并）是最小上界
为SC中每一集合定义

其它
其它——
——MLS
MLS的引申
的引申
Denning的公理
SC是有限的
比较保护系统和safety问题
→是SC上的偏序
自反性
传递性
反对称性
SC有一个下界——如：公开数据
/（合并）是最小上界
为SC中每一集合定义

其它
其它——
——MLS
MLS的引申
的引申
无干扰模型
无干扰的目标要求，如果u>u’，用户u的输入不会对u’
看到的输出产生影响。
用户u’不会看到u的任何操作产生的影响。
运行时被许可的操作可以产生隐蔽流
使u写资源x
使u’写资源y
y依赖于写x的操作
填满磁盘；查看CPU延迟，看到y的值就隐含着x的值
一般的，当SC(u) > SC(u’)时，run(u’, hist.cmd(u)) = 
run(u’, hist
)——系统必须清除cmd(u)的影响
u’未看到cmd(u)的影响

大纲
大纲
什么是访问控制策略和模型
机密性策略及模型
访问监控器设计实例
完整性模型

什么是完整性
什么是完整性
完整性考虑谁可以写文件
谁会影响文档（内容）的完整性
DNS记录
完整性保护思想
思想1：关键数据不能被改变
思想2：关键的数据只以正确的方式被改变
思想3：关键的数据只通过特定的可信程序改变
思想4：关键的数据只按授权用户的意愿改变

Biba
Biba完整性
完整性
Biba为完整性定义了一个BLP的对偶
完整性需求：不依赖来自低完整性主体的数据
只允许信息从高完整性流向低完整性
No read down , no write up
用户只能在完整性级别不高于Ta的地方创建内容
用户只能看不低于Ta的完整性级别的内容

LOMAC
LOMAC
低水印模型
根据实际的依赖改变完整性级别
主体最开始处于最高完整性级别但完整性级别随着被访问的客体改变最终，主体的完整性与被访问过的级别最低的客体一致

Biba
Biba和
和LOMAC
LOMAC
都是基于信息流的完整性模型
Is a good goal because…
没有错误的否定——攻击需要非法信息流
可以定义数据和功能的安全需求
Is a poor goal because…
功能可能和安全性发生冲突
怎样知道许可权是非法的，但对功能是必须的？
能否验证策略是正确的？
可以。定义了一个基于安全的策略。例外情况怎么办？

Clark
Clark-
-Wilson
Wilson完整性
完整性
将商业中的完整性映射到计算机
高完整性数据（对象）
“Constrained Data Items” (CDIs)
高完整性进程（程序）
“Transformation Procedures” (TPs)
一开始就检查数据的完整性（验证）
“Integrity Verification Procedures” (IVPs)
低完整性数据
“Unconstrained Data Items”(UDI)
前提
如果IVP能验证初始完整性
高完整性的数据只能被TP修改
那么就能保持系统的完整性

Clark
Clark-
-Wilson
Wilson模型描述
模型描述
包括一套验证和实施规则来管理完整性
C1——IVP执行时，必须保证CDI是有效的
C2——对于一些相关的CDI集合，TP必须将其从一个
有效状态转换为另一个有效状态
C3——允许的关系必须满足职权分离
C4——所有TP必须产生足以重构操作的日志信息
C5——任何以UDI为输入的TP只能针对UDI的所有可
能取值执行有效转换工作。TP或者接受（转换为CDI）
或者拒绝UDI

Clark
Clark-
-Wilson
Wilson模型描述
模型描述
包括一套验证和实施规则来管理完整性
E1——系统必须维护一个验证关系列表，保证只有有
权操作CDI的TP可改变CDI
E2——系统必须将用户与TP和CDI集合关联在一起
E3——系统必须验证每个试图使用TP的用户
E4——只有TP的验证者可以改变与TP关联的实体列表

Clark
Clark-
-Wilson Permissions
Wilson Permissions

Clark
Clark-
-Wilson Permissions
Wilson Permissions

Clark
Clark-
-Wilson Permissions
Wilson Permissions
用户可使用TP访问CDI的条件
用户被授权访问CDI
TP被授权访问CDI
用户被授权访问TP

Clark
Clark-
-Wilson
Wilson的问题
的问题
保证功能
保证IVP、TP是有效的（如正确的）
正确性怎样定义？
处理完整性数据
TP必须对收到的UDI进行更新或删除
现实情况：这是一个好模型，但对于很多应用程序要
求太高。

大纲
大纲
什么是访问控制策略和模型
机密性策略及模型
中性模型介绍
完整性模型

中国墙
中国墙
也叫Brewer and Nash模型
在利益冲突下保护数据
你的员工可能可以读取多个数据集的数据
当他们读取一个客户的数据（如GM）时，会自动被禁
止读取有冲突的客户的数据（如Ford）
目标：保护保密性和完整性的安全模型
同时，防止通过利益冲突集合之外的数据集泄漏信息

中国墙
中国墙
简单安全规则
读取公司数据集中的对象的访问被许可，如果
公司数据集中的对象已经被访问了
对象在一个不同的利益冲突集合中
*安全规则
写公司数据集中的对象的访问被许可，如果
访问被简单安全规则许可
在另一个公司的数据集中，没有数据可被读取

RBAC
RBAC模型
模型
基于角色的访问控制
NIST，上世纪90年代提出
角色
业务系统中的岗位、职位、分工
如：在学校，教师、学生、校长
基本思想
为用户分配角色，为角色配置权限。用户通过承担不
同的角色获得访问权限。

RBAC
RBAC
遵循的三个基本原则
最小特权：
分配给用户的特权不超过其完成工作必须的权限
引入“会话”概念，是激活角色的集合。
•权限：激活角色权限并集
•会话依用户意愿终止
职责分离：
用户不能同时拥有互斥的角色
如会计和出纳
数据抽象
除OS中一般的读、写、执行权限外，根据实际需要定义访问权限

RBAC
RBAC
NIST的RBAC模型的四个组成部分
基本模型RBAC0（core RBAC）
角色分级模型RBAC1 （HierarcalRBAC）
角色限制模型RBAC2 （Constraint RBAC）
统一模型RBAC3

RBAC
RBAC
RBAC0

RBAC
RBAC
RBAC1
角色等级
角色偏序关系
实现角色的继承

RBAC
RBAC
RBAC2
增加了职责隔离
互斥角色
基数约束
角色被分配的用户数量受限
用户的角色数量受限
角色对应的权限数量受限
先决条件角色
当且仅当是另一角色的成员
当且仅当有某权限
运行时互斥

RBAC
RBAC特点
特点
对主体角色抽象、访问约束等安全特征进行描述
缺乏访问控制过程对客体安全特征的抽象
在大型分布式环境下，缺乏良好的自我管理能力

TE & DTE
TE & DTE
Type Enforcement
1985年，Boebert& Kain提出，用于LOCK6系统
SELinux中使用
Domain & Type Enforcement
Daniel F.Sterne提出
模型思想
系统——主体、客体的集合
主体属性——域
客体属性——型
域定义表（DDT）
域对不同型客体的操作权限
域交互表（DDIT）
域间的许可访问模式

TE & DTE
TE & DTE
DTE的四种策略描述语句
型：一个或多个客体类型声明
type unix_t;
域：定义了一个受控的执行环境
入口点程序路径
对客体型的访问权限
对其他域中主体的访问权限
如：
•domain login_d=(/bin/login),(rwxd->unit_t),(exec->engineer_d); 
初始化域：选择第一个进程的域
Initial_domainsystem_d;
型赋值：将型与文件关联
assign –r unix_t/;

TE & 
TE & DTE
DTE——
——评价
评价
没有明确指出策略的安全目标
可表达系统中的任意安全目标，策略中立
但应用时，访问控制表会迅速膨胀，安全性很难验证
需要对系统设计实现机理充分了解，才能定义策略

如何进行安全系统设计
如何进行安全系统设计
定义安全目标
定义信任模型
定义威胁模型
实现参考验证机制
定义正确的安全策略
有效的参考监控机制
保护系统

大纲
大纲
系统访问验证机制发展历程
FLASK架构介绍
SELinux基本机制及策略语言
LSM框架介绍

系统访问验证机制发展历程
系统访问验证机制发展历程
OS的运行环境不断变化
专用系统→通用系统
策略无法在系统中写死
需要保护的对象不再单一
需要支持系统自身的可扩展性
运行环境封闭→运行环境开放
对手层出不穷
策略可能随环境而变化
OS全权负责访问验证→OS是访问验证链条中的一个环节
访问验证机制需要与外部协同
系统安全目标单一→系统需协调各方安全关切
需要进行安全策略的复合

系统访问验证机制发展历程
系统访问验证机制发展历程
实施安全策略的访问验证机制发展的四个阶段
第一阶段：支持单一安全策略
MAC、DAC结合形成单一的系统安全策略
第二阶段：支持多安全策略
机密性、完整性等需要支持多个分离的安全策略
GFAC为代表
第三阶段：支持安全策略的灵活性
支持修改现存策略、撤销许可权等
FLASK为代表
第四阶段：支持安全策略的环境适应性
可根据环境的变化切换安全策略
可将环境因素（如时间、物理位置）纳入策略考虑范围
当前状态
未来方向

系统访问验证机制发展历程
系统访问验证机制发展历程
关于多安全策略
1992年，Hosmer
第一次提出
需要多策略的情况
系统安全目标不唯一，
•如：保密性+完整性
系统为多个成员服务，各有各的目标和计划
•如：系统属主+所在单位
系统由多个仲裁组件组成
•如：安全数据库+网络访问控制
系统必须适应变化的环境
•如：和平时期+战争时期
产生的原因：安全需求多样化

安全策略的灵活性（flexibility）
系统必须支持对底层客体的细粒度访问控制，以实施
由安全策略控制的高层功能
系统必须确保访问权限的传递与安全策略保持一致
安全策略在通常情况下是不固定的
系统访问验证机制发展历程
系统访问验证机制发展历程

GFAC
GFAC体系结构
体系结构
主体
访问控制
实施部件
（AEF）
客体
访问控制判定部件（ADF）
……..
自主访问控制规则集
机密性访问控制规则集
完整性访问控制规则集
访问控制信息（ACI）
1.访问请求
2.请求决策
3.信息获取4.返回决策
5.更新信息6.授权或拒绝请求
7.访问单一系统中实现多种策略支持
用于UNIX/Linux系统
分离决策及判定机制

FLASK
FLASK
体系结构
体系结构
起源于DTOS原型系统
目标是动态策略，通过策略与实施机制相隔离实现
起源于微内核系统，在宏内核系统中也适用（SELinux
）
详细见后面介绍
客户端
客体管理器
策略实施
安全服务器
安全策略
对象请求
查询
决策
实施策略

大纲
大纲
系统访问验证机制发展历程
FLASK架构介绍
SELinux基本机制及策略语言
LSM框架介绍

FLASK
FLASK
策略灵活性分析
理想情况：
可将系统看成一个进行原子状态转换的抽象机
安全策略了解所有系统的状态，并对系统每个操作施加影响
•许可/拒绝操作
•原子性地介入处理过程
•可以修改系统的安全策略，吊销过去授予的访问权限
现实情况
能够了解哪些系统状态和操作的子集与安全相关
方案的灵活性依赖于，如何使这些受控操作完备，状态的哪一部分让安全策略感知
受控操作的粒度影响灵活性的程度，因为这影响共享操作被控制的粒度

FLASK
FLASK
策略灵活性分析（续）
策略灵活性要能支持多种策略
需要吊销原来已经授予的访问权限
进行访问决策所需的输入类型
策略决策对外部因素的可感知性
策略决策的可传递性
要处理受控操作执行时的策略改变
介入必须是原子的，以保证策略的一致性
原子性有时不易达到，比如文件打开时进行决策，读写操作发生在之后
系统必须了解策略改变时，许可权是否被吊销
需标识进行中的操作
三种处理：放弃并返回错误、重启操作检查许可权、等待操作结束（等待不可取，时间不可控）

Flask
Flask
Flask的设计
客体管理器：实施安全策略
安全服务器：进行安全决策
客户端
客体管理器
策略实施
安全服务器
安全策略
对象请求
查询
决策
实施策略

Flask
Flask
Flask的设计
设计的主要目标：保证策略的一致性
其他目标：应用程序透明、深度防御、最小化性能开销
客体管理器的三个主要元素
处理安全服务器决策的接口
•实体间的访问许可
•客体的安全标记
•多实例化：针对一个特定请求，确定处理的资源集合
Access vector cache（AVC）：缓存决策
注册处理策略改变通知的服务
客体管理器必须定义
将标记赋予客体的机制
控制策略，安全决策如何使用和实施
策略改变时的处理程序

Flask
Flask
客体标记
安全上下文：用户、应用程序可理解
SID：
固定长度，指向安全上下文，安全服务器维护SID的映射
客户端（SID C）
客体管理器
客体
安全服务器
创建对象请求
新SID请求
实施策略
New SID（SID，SID，ObjType）
SID/上下文映射
策略逻辑（标签规则）新SID

Flask
Flask
安全决策的请求与缓存
客户端（SID C）
客体管理器
客体
安全服务器
修改对象请求
访问规则
实施策略
访问检查（SID，SID，Perm）
SID/上下文映射
策略逻辑（访问规则）访问请求
AVC。。。。。。

Flask
Flask
FLASK的多实例化
客户端（SID C）
客体管理器
客体
安全服务器
创建客体请求
MbrSID
实施策略
成员SID（SID，SID，ObjType）
SID/上下文映射
策略逻辑（成员规则）
MbrSID请求

Flask
Flask
吊销支持
需求
策略改变，客体管理器的行为必须反映改变
策略改变必须及时完成
三步协议
安全服务器通知所有可能要吊销许可的客体管理器
客体管理器更新其内部状态
客体管理器通知安全服务器，更新操作已经完成

FLASK
FLASK
安全服务器
需求
提供SID到安全上下文的映射
为新客体申请SID
通过回调函数管理客体管理器的AVC
提供策略改变通知接口
在服务器端也进行缓存
对分布式系统
对分布式系统，安全服务器是策略的本地缓存
有本地定义的策略，及高层的策略协调机制

FLASK
FLASK
安全服务器
Flask安全服务器是代码及策略数据库的组合
策略语言可表示很多策略
任何可表达的安全策略都可以简单地通过改变策略数据库实现
但是一些策略改变可能需要代码的变化，或替换安全服务器
但始终不需要改变客体管理器
原型服务器实现了
MLS
TE
Identity based access control
RBAC
其他客体管理器
文件服务器
网络服务器
进程管理器

大纲
大纲
系统访问验证机制发展历程
FLASK架构介绍
SELinux基本机制及策略语言
LSM框架介绍

LSM
LSM访问控制框架
访问控制框架
NSA在Linux实现FLASK——SELinux
2001年，Linus 设立Linux Security Module(LSM)
项目
内核需要一个通用的访问控制框架
集成各个安全项目的影响
设计目标
足够通用（不同的安全模型只需加载一个内核模块即可）
概念上简单
支持POSIX.1e权能（作为一个可选的安全模块）
对内核内部对象的访问进行仲裁（task
、inode、
open file）
安全策略决策信息最全面

LSM
LSM访问控制框架
访问控制框架
LSM访问控制示意图
用户态进程
用户空间
打开系统调用
错误检查
DAC检查
LSM钩子
节点访问
检查安全上下文请求是否通过策略检查？授权或拒绝
内核空间

LSM
LSM工作
工作
Linux内核的五处修改
在特定内核数据结构中加入安全域
在内核代码的各处加入安全钩子点函数调用
增加一个通用的安全系统调用
使安全模块注册、注销的函数
将权能逻辑加入一个可选的安全模块

LSM
LSM安全域
安全域
使安全模块可以在内核对象中关联安全信息
实现为void*指针
完全由安全模块管理
怎样处理安全模块加载前创建的对象？

LSM
LSM钩子点
钩子点
一些可被安全模块覆盖的，用来管理安全域，及仲裁
对内核对象访问的功能调用
钩子点通过存储在security->ops表中的函数指针调
用
钩子点主要是用来限制的

LSM
LSM钩子点
钩子点

LSM API
LSM API

POSIX
POSIX权能
权能
POSIX.1e权能逻辑被移入一个可选模块
权能对传统超级用户的特权进行了划分
许可权

Hook
Hook的细节
的细节
与自主控制不同
更多对象类型
29种不同的客体型
每个packet、superblock、共享内存、进程
不同类型文件
更细粒度的操作
文件：ioctlcreate getattrsetattrlock append unlink
系统标记
不依赖于用户
模块定义的授权及策略
不由内核定义

LSM
LSM使用
使用
在Linux 2.6并入内核
包级的控制出现在2.6.16之后
模块
POSIX 权能模块
SELinux模块
DTE
Openwall
LIDS
AppArmor
不是所有人感兴趣

对比：
对比：TrustedBSD
TrustedBSDMAC
MAC框架
框架

对比：
对比：TrustedBSD
TrustedBSDMAC
MAC框架
框架
支持以内核模块方式灵活扩展系统中安全策略
可多模块同时加载
框架管理接口
sysctl、loader
、系统调用
考虑了策略链表、标记、策略间的并发与同步
入口函数
内核服务调用API通知MAC 框架安全事件的发生
内核服务向MAC 框架提供一个指向安全对象的策略无
关安全标记数据结构的指针
由标记管理入口函数维护
策略组合
使用合成运算子组合汇总（目前是硬编码）

LSM
LSM及完全仲裁
及完全仲裁
LSM主要关注完全仲裁
如何选择安全敏感操作？
基本是随意进行的（ad hoc ）

大纲
大纲
系统访问验证机制发展历程
FLASK架构介绍
SELinux基本机制及策略语言
LSM框架介绍

Linux
Linux的参考监控器
的参考监控器
LSM提供了一个参考监控器的接口
完全仲裁
需要模块及基础设施来达到另外两个目标
Tamperproofing
Verifiability
SELinux是一个以参考监控器保证为目标的全面的参
考验证机制

SELinux
SELinux的历史
的历史
追溯到1980年的Mach微内核项目
DTMach(1992开始)
DTOS (1995)
Flask (1999)
SELinux(2000开始)
由安全核设计理念开始
但有很多实际的考虑

FLASK
FLASK
组件
组件
Object Manager
获得访问、标记、
决策的接口
AVC
策略改变处理
Security Server
SID/Context 映
射
策略逻辑定义
客户端
客体管理器
策略实施
安全服务器
安全策略
对象请求
查询
决策
实施策略

SELinux
SELinux架构
架构

Models
Models
Revised TE Model
为进程和对象都定义类型属性
除型外还引入安全类的概念
Simplified RBAC Model
支持基本RBAC 和层级RBAC.
每个用户有一个角色集合
定义角色可进入的域，具体权限定义留给TE
User Identity Model
与系统的UID不同
在配置文件中定义

SELinux
SELinux模型关系
模型关系

SELinux
SELinux相关概念
相关概念
security context
主体或客体安全属性的组合
user:role:type如：system_u:object_r:initrc_tfor file /etc/rc.conf
.
SID
安全标识，与安全上下文对应
相同安全上下文的不同主体、客体可使用相同的SID.
预留了初始的SIDs. 
全局定义
Initial SIDs
Security Classes
Access Vector Permissions

SELinux
SELinux决策
决策
Parameters for making decision
(ssid, osid, o_class)
Label Decision
标签转换决策，定义新主体、客体的标签
Access Decision
Request SS
SS 针对客体的许可访问权限
返回决策，在AVC中缓存

SELinux
SELinux引入原因
引入原因
不认为传统的完整性是实际可实现的
太多例外
商业系统不能接受传统完整性的各种限制
取而代之，关注通过最小特权实现的对访问全面控制
的完整性
系统组件完整性
所有用户进程以同样的标记运行
最小特权怎样影响访问模型？

SELinux
SELinux策略
策略
TE策略的主要目标
为给定程序定义访问控制
影响决策的因素
程序保护
•防止干扰/
修改程序资源
最小特权
•限制程序只拥有必须的最小访问权
限制错误传播
达成更多的安全保证
角色关联用户到域
一个域类型是为用户而不是程序设计的

SELinux
SELinux策略
策略
TE策略的其它目标
自身保护
内核保护自身及其资源
保护策略本身
实施其它强制策略
信息流
域隔离
守护应用程序（控制信息流）
所有都关注于域（程序）访问
不是用户

SELinux
SELinux策略语言
策略语言——
——属性定义
属性定义
具有相同属性的类型的集合标识
属性与型的关系是多对多的关系
Syntax:
attrib_decl-> ATTRIBUTE identifier ‘;’
Example:
attribute domain;
attribute privuser
;
attribute privrole;

SELinux
SELinux策略语言
策略语言——
——型定义
型定义
Every type in the system must be defined.
Syntax:
type_decl -> TYPE identifier opt_alias_def opt_attr_list ’;’opt_alias_def -> ALIAS aliases | emptyaliases -> identifier | ’{’ identifier_list ’}’identifier_list -> identifier | identifier_list identifieropt_attr_list -> ’,’ attr_list | emptyattr_list -> identifier | attr_list ’,’ identifier
Example:
type ftpd_t domain, privuser, privrole, privlog, privownertype ftpd_exec_t file_type, exec_type, sysadmfiletype ftpd_etc_t, file_type, sysadmfiletype ftpd_var_run_t file_type, sysadmfile, pidfile

SELinux
SELinux策略语言
策略语言——
——转换规则定义
转换规则定义
Specify the new domain for a process or the new type for an 
object. Both are based on a pair of types and a class. Syntax:type_transition_rule-> TYPE_TRANSITION source_types
target_types’:’ classes new_type’;’source_types-> settarget_types-> setclasses -> setnew_type-> identifierset -> ’*’ | identifier | ’{’ identifier_list’}’ | ’~’ identifier | ’~’ ’{’ 
identifier_list‘}’Example:type_transitioninitrc_tftpd_exec_t:processftpd_ttype_transitionftpd_twyj_home_t:filewyj_home_ftpincoming_ttype_transitionftpd_tshell_exec_t:processuser_t

SELinux
SELinux策略语言
策略语言——
——转换许可规则定义
转换许可规则定义
Not used by kernel but for security-aware 
applications.
The same syntax with Type Transition
Example:
type_change user_t tty_device_t:chr_file 
user_tty_device_t;
type_change sysadm_t tty_device_t:chr_file 
sysadm_tty_device_t;
type_change user_t sshd_devpts_t:chr_file 
user_devpts_t;
type_change sysadm_t sshd_devpts_t:chr_file 
sysadm_devpts_t;

SELinux
SELinux策略语言
策略语言——
——访问控制规则定义
访问控制规则定义
Specify a set of permissions based on a type pair and object 
class. Syntax:te_av_rule-> av_kindsource_typestarget_types’:’ classes 
permissions ’;’av_kind-> ALLOW | AUDITALLOW | DONTAUDITsource_types-> settarget_types-> setclasses -> setpermissions -> setset -> ’*’ | identifier | ’{’ identifier_list’}’ | ’~’ identifier | ’~’ ’{’ 
identifier_list‘}’Example:allow ftpd_tftpd_exec_t:file{ read execute entrypoint}allow ftpd_tftpd_etc_t:file{read}allow ftpd_tuser_t:processtransition

SELinux
SELinux策略语言
策略语言——
——访问
访问控制保证规则定义
控制保证规则定义
Explicitly specify what cannot appear in the policy. Checked by 
policy compiler.Syntax:te_avassert_rule -> NEVERALLOW source_types target_types ’:’ 
classes permissions ’;’source_types -> settarget_types -> setclasses -> setpermissions -> setset -> ’*’ | identifier | ’{’ identifier_list ’}’ | ’~’ identifier | ’~’ ’{’ 
identifier_list ‘}’Example:neverallow domain ~domain:process transition;neverallow ~{ kmod_t insmod_t rmmod_t ifconfig_t } self:capability 
sys_module;neverallow local_login_t ~login_exec_t:file entrypoint;

SELinux
SELinux策略语言
策略语言——
——角色定义
角色定义
Specify a particular domains the role is authorized.
Syntax:
role_decl -> ROLE identifier TYPES types ‘;’
types -> set
set -> ‘*’ | identifier | ‘{‘ identifier_list ‘}’ | ‘~’ identifier | 
‘~{‘ identifier_list ‘}’ 
Example:
role system_r types { kernel_t initrc_t getty_t klogd_t };
role user_r types { user_t user_netscape_t };
role sysadm_r types { sysadm_t run_init_t };
Commonly used roles:
system_r, sysadm_r, user_r

SELinux
SELinux策略语言
策略语言——
——角色转换许可规则定义
角色转换许可规则定义
Specify authorized transitions between roles 
based on a pair of roles.
Syntax
role_allow_rule -> ALLOW current_roles 
new_roles ’;’
current_roles -> set
new_roles -> set
set -> ’*’ | identifier | ’{’ identifier_list ’}’ | ’~’ 
identifier | ’~’ ’{’ identifier_list ‘}’
Example
allow system_r { user_r sysadm_r };
allow user_r sysadm_r;
allow sysadm_r system_r;

SELinux
SELinux策略语言
策略语言——
——用户定义
用户定义
Define a user that will appear in the security context 
and is known through policy.
Syntax
users -> user_decl| users user_decluser_decl-> USER identifier ROLES set ’;’set -> ’*’ | identifier | ’{’ identifier_list’}’ | ’~’ identifier | ’~’ ’{’ 
identifier_list‘}’
Example
user system_uroles system_r
;user root roles { user_rsysadm_r};user sqhroles { staff_rsysadm_r};user wyjroles user_r
;
Commonly used users:
system_u, user_u

SELinux
SELinux策略语言
策略语言——
——限制定义
限制定义
Specify additional constraints on permissions using 
bool expression. Complex but useful.
Syntax:
omitted  …
Reserved keywords: u1, u2, r1, r2, t1 t2, not, and, or, ==, !=
Example:
constrain process transition ( u1 == u2 or t1 == privuser );
constrain process transition ( r1 == r2 or t1 == privrole );
constrain dir_file_class_set { create relabelto relabelfrom }
( u1 == u2 or t1 == privowner );

SELinux
SELinux策略语言
策略语言——
——安全上下文标记
安全上下文标记
Initial SID contexts
Filesystem labeling behavior
fs_use_xattr : from EA
fs_use_task : from creating task
fs_use_transition : from transition rule
Network objects labeling
portcon, nodecon, netifcon
File labeling
/bin(|/.*) system_u:object_r:bin_t
/bin/login system_u:object_r:login_exec_t
/bin/bash system_u:object_r:shell_exec_t
/usr/home/wyj wyj:user_r:wyj_home_t

SELinux
SELinux实例
实例
对于运行passwd程序的用户
只有passwd有权限修改/
etc
/shadow
用户需要运行passwd程序的权限
allow user_tpasswd_exec_t:fileexecute (user can exec /
usr
/bin/
passwd
)
allow user_tpasswd_t:processtransition (user gets passwdperms)
必须从user_t转换到passwd_t
allow passwd_tpasswd_exec_t:fileentrypoint(run w/ passwdperms)
type_transitionuser_tpasswd_exec_t:processpasswd_t
passwd可以执行相关的操作
allow passwd_tshadow_t:file{read write} (can edit passwdfile)

Biba安全策略模型研讨

问题（一）
在信息通信过程中，机密性与完整性需要达到的目标是什
么？两者分别是如何实现的？请举例说明其实现过程
。
在系统安全中，BLP模型和Biba模型的机密性与完整性需
要达到的目标是什么？两者分别是如何实现的？请举例说
明其实现过程。
机密性与完整性在信息通信与系统安全（BLP模型和
Biba
模型）中的含义有何差异？试分别举例说明。
设H>L是Biba模型的两个完整性级别。请按照下表的安全
标签，以访问控制矩阵的方式列出相应的访问权限。
请设
定一个现实场景，赋予这些主体和客体以实际意义，并用
访问控制矩阵说明访问权限。
2

信息通信过程中的机密性与完整性
机密性与完整性目的
机密性：信息在从发送者到接收者之间传送的过程中未被泄
漏
完整性：信息在从发送者到接收者之间传送的过程中未被修
改
机密性与完整性实现方案
机密性：加密（如RSA、AES加密）
完整性：添加完整性标签（如哈希值）

安全访问控制中的机密性与完整性
机密性与完整性目的（BS7799
BS7799-
-1:1999
1:1999）
机密性：保护信息不受未经授权的访问和泄露。
完整性：保护信息不被未经授权的实体更改和破坏，确保信
息是精确的，并且是完备的。
机密性与完整性实现方案
机密性：机密性访问控制策略（如BLP）
完整性：完整性访问控制策略（如Biba）

BLP机密性访问控制策略
Bell-LaPadula模型
1973年，D.ElliottBell和Leonard J. LaPadula提出的一种
多级安全的机密性模型
在模型中定义了：
主体(Subject)-引起信息流动的发起者(进程)
客体(Object)-信息流动中访问的对象(文件、目录、设备等)
安全标记(Level)-安全标记是主体和客体
所具有的属性，由等级和范畴确定(clasification, set of categories)
访问属性(Attributes)-读、写、执行和盲写
访问控制矩阵-主体对于客体的访问许可

BLP机密性访问控制策略
简单安全特性(ss-property)：主体S允许对客体O进行读访问
，仅当Level(S) >= Level(O)
不上读
阻止直接的信息泄露
*安全特性(*-property)：主体S允许对客体O进行写访问，仅当
Level(S) <= Level(O)
不下写
阻止间接的信息泄露

BLP机密性访问控制策略

*
*安全特性的解释
安全特性的解释

BLP机密性访问控制策略
BLP
BLP的简单安全特性和
的简单安全特性和*
*安全特性对信息的安全控制很重要
安全特性对信息的安全控制很重要
。是否这两个特性就足够了？
。是否这两个特性就足够了？

Can a commanding general with a Top Secret 
Can a commanding general with a Top Secret 
clearance email marching orders to a foot soldier 
clearance email marching orders to a foot soldier 
with no clearance? No!
with no clearance? No!

Can a corporal with no clearance overwrite the war 
Can a corporal with no clearance overwrite the war 
plan? Nothing in our rules stops it, but that
plan? Nothing in our rules stops it, but that
’
’s an 
s an 
integrity problem
integrity problem!
!

Biba完整性访问控制策略
Biba模型
1977年，Biba等人受BLP模型的启发，第一次提出了一个完
整性模型
在模型中定义了：
主体(Subject)-引起信息流动的发起者(进程)
客体(Object)-信息流动中访问的对象(文件、目录、
设备等)
完整性安全标记(Level)-安全标记是主体和客体所具有的属
性，由等级和范畴确定(clasification, set of categories)

Biba完整性访问控制策略
严格完整性策略：BLP策略的对偶
简单完整性(Simple Integrity Property):主体
s允许
对客体o进行读访问，仅当i (s) <= i (o).
不下读
阻止脏数据造成的间接破坏
完整性*属性Integrity *-Property:主体s允许对客体o
进行写访问，仅当i (o) <= i (s).
不上写
阻止直接的恶意篡改

Biba模型中的访问控制标签与访问控制矩阵
设H>L是Biba模型的两个完整性级别
访问控制标签
访问控制矩阵

Biba模型中的访问控制标签与访问控制矩阵
访问控制矩阵
实际场景Subj1、Subj2、Subj3：一位（数学、计算机学及统计学）教授、一个小学一年级学生、一个计算机系大四学生Obj1、Obj2、Obj3Obj1：一个复杂的统计学问题文档，需要用到复杂的数学理论及计算机学知识Obj2：数学计算题文档，1+1等于几？Obj3：一个较复杂的的统计学计算问题文档H、L：专家、初学者A、B、C：数学、计算机学、统计学解释第一行：教授是专家，回答三个课题很容易（可写），但不能读第二行：小学生需要吸收知识（可读），但不能乱画（只能回答1+1等于几）第三行：计算机系大四学生可研究统计学问题，但没法解决该问题（不可写）；会计算1+1=?，也没必要参看小学生的答案（不可读）；不熟悉统计学（不可读、不可写）

问题（二）
设H>L是Biba模型也是BLP模型的两个级别。请按照如下的安
全标签分析访问权限。
Biba模型中除了严格完整性策略(Strict integrity)，还有低水印策略
（Low water mark policy）及环策略（Ring policy），请举例说明这
三种策略在访问权限上的差异。
Biba与BLP模型分别有什么样的缺陷？应该如何弥补这些缺陷？
请分
析、举例说明。

若H>L既是Biba模型也是BLP模型的两个级别
Biba（严格完整性策略）策略是BLP策略的对偶
Biba策略中Simple Integrity Property与BLP策略中
ss-
Property的交集是
Subject S can read object O only if i (S) <= i (O) and i 
(S) >= i (O), i.e., i (S) = i (O)
Biba策略中Integrity *-Property与BLP策略中*-Property
的交集是
Subject S can write to object O only if i (O) <= i (S) and 
i (O) >= i (S), i.e., i (S) = i (O)
因此，在该条件下，仅当S的标签（级别，范畴）与O的标
签相等（级别相同，范畴相同）时，才能读或写
教授和大学生都不能读、写1+1=？文档，因为级别或（
和）范畴不同

若H>L既是Biba模型也是BLP模型的两个级别标签
结论
Biba模型中的完整性标签与BLP模型中的机密性标签是两
种不同的标签系统
若在同一系统中实现两种标签，则主体和客体就都具有两
个不同的标签（两个级别，两个范畴）

Biba模型的严格完整性策略、低水印策略及环策略
严格完整性策略
Simple Integrity Property: Subject s can read object o only if i (s) <
=i (o).
Integrity *-Property: Subject s can write to object o only if i (o) <
=i (s).
低水印策略
s can always read o; after reading i(s) min[i(s), i(o)]
s can write to o only if i (o) <=i (s)
环策略
Any subject can read any object, regardless of integrity levels.
Subject s can write to object o only if i (o) <=i (s)

Biba模型的严格完整性策略、低水印策略及环策略
三者的一个重要的不同点是对主体的信任程度有所不同
严格完整性策略对主体设置了很小的信任度，限制了所有的
读、写以实现完整性信息不向上流动
水印策略的特点是主体的完整性标签单调递减
在实际应用中会导致该主体很快就不能访问系统大部分客体
环策略关注与直接修改并解决低水印策略的缺点
主体的标签的降低
思考
环策略是否对主体做了某些假设，这些假设是低水印策略所
没有的？

Biba模型的严格完整性策略、低水印策略及环策略
环策略更信任主体，相信主体能正确地过滤接收到的信息
Biba的三种策略都阻止主体的完整性信息上写功能

Biba与BLP模型的缺陷？
BLP的缺陷
跨越状态的情形
设系统中主体s1,s2,o1,o2f
S(s1)=f
C(s1)=f
O(o1)=high
f
S(s2)=f
C(s2)=f
O(o2) =low
执行序列：
s1访问o1→读→释放操作→ f
C(s1)=low → s1访问o2→写o2→
每个状态都是安全的，但存在非法信息流
解决方案：平稳定律：主体不能改变当前安全级

Biba与BLP模型的缺陷？
BLP的缺陷
不同级别的主体有信息通信的需要设系统中主体
军官email命令士兵出击
解决方案：可信主体

Biba与BLP模型分别有什么样的缺陷？应该如何弥补这些缺陷？请分析、
举例说明。
Biba模型的缺陷
完整标签确定的困难性
BLP机密性策略可与政府或军队分级机制结合
完整性的分级和分类缺少相应的标准
在有效保护数据一致性方面是不充分的
内部完整性威胁应该通过程序验证来解决，但在该模型中并
没有包括这个要求
Biba模型与BLP模型结合的困难性
应用的内在复杂性，导致设置更多的范畴来满足其在机密性
、完整性方面的需求
这些范畴在结合使用时难以配合使用
很容易出现进程不能存取任何数据的局面

总结
比较学习Biba完整性安全策略模型与BLP机密性安全策略
模型的基本知识
理解完整性级别标签与机密性级别标签的不同作用
。
了解Biba模型的三种完整性策略及其差异性分析。
了解Biba与BLP模型的不足之处。

谢谢！&问答


